# -*- coding: utf-8 -*-
"""CricketModel.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/14jidO7yW-tRWYgvJlztcj1rRI0tfZrpR
"""

# Mount Google Drive
from google.colab import drive
drive.mount('/content/drive')

# Create project directory
!mkdir -p "/content/drive/MyDrive/IPL_Prediction_Model"

# Install required libraries
!pip install cricsheet pandas numpy matplotlib seaborn scikit-learn xgboost catboost

# Download data
!wget https://cricsheet.org/downloads/ipl.zip -P "/content/drive/MyDrive/IPL_Prediction_Model/data"
!unzip "/content/drive/MyDrive/IPL_Prediction_Model/data/ipl.zip" -d "/content/drive/MyDrive/IPL_Prediction_Model/data"

# Install required libraries
!pip install pandas numpy matplotlib seaborn scikit-learn xgboost catboost pyyaml beautifulsoup4 tqdm

!mkdir -p "/content/drive/MyDrive/IPL_Prediction_Model/data"
!mkdir -p "/content/drive/MyDrive/IPL_Prediction_Model/models"
!mkdir -p "/content/drive/MyDrive/IPL_Prediction_Model/results"

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.model_selection import train_test_split, GridSearchCV
from sklearn.preprocessing import StandardScaler, OneHotEncoder
from sklearn.compose import ColumnTransformer
from sklearn.pipeline import Pipeline
from sklearn.ensemble import RandomForestClassifier
from sklearn.metrics import accuracy_score, classification_report, confusion_matrix
import xgboost as xgb
from catboost import CatBoostClassifier
import warnings
warnings.filterwarnings('ignore')

# Fix the process_match_data function to handle seasons correctly
def process_match_data():
    """Process YAML match data files into a structured DataFrame"""
    import yaml
    import glob
    import os
    from tqdm.notebook import tqdm

    matches = []
    yaml_files = glob.glob("/content/drive/MyDrive/IPL_Prediction_Model/data/*.yaml")

    for file_path in tqdm(yaml_files, desc="Processing matches"):
        try:
            with open(file_path, 'r') as f:
                data = yaml.safe_load(f)

            # Skip matches without proper information
            if not data or 'info' not in data:
                continue

            # Extract basic match info
            match_info = {
                'match_id': os.path.basename(file_path).split('.')[0],
                'season': data['info'].get('season', 'Unknown'),  # Use int() if possible
                'date': data['info'].get('dates', ['Unknown'])[0],
                'venue': data['info'].get('venue', 'Unknown'),
                'city': data['info'].get('city', 'Unknown'),
                'team1': data['info']['teams'][0] if 'teams' in data['info'] and len(data['info']['teams']) > 0 else 'Unknown',
                'team2': data['info']['teams'][1] if 'teams' in data['info'] and len(data['info']['teams']) > 1 else 'Unknown',
            }

            # Add toss information if available
            if 'toss' in data['info']:
                match_info['toss_winner'] = data['info']['toss'].get('winner', 'Unknown')
                match_info['toss_decision'] = data['info']['toss'].get('decision', 'Unknown')
            else:
                match_info['toss_winner'] = 'Unknown'
                match_info['toss_decision'] = 'Unknown'

            # Add winner information if available
            if 'outcome' in data['info']:
                if 'winner' in data['info']['outcome']:
                    match_info['winner'] = data['info']['outcome']['winner']
                elif 'result' in data['info']['outcome']:
                    match_info['winner'] = 'no result'
                elif 'eliminator' in data['info']['outcome']:
                    match_info['winner'] = data['info']['outcome']['eliminator']
                else:
                    match_info['winner'] = 'Unknown'
            else:
                match_info['winner'] = 'Unknown'

            matches.append(match_info)
        except Exception as e:
            print(f"Error processing {file_path}: {e}")

    # Create DataFrame
    df = pd.DataFrame(matches)

    # Handle season data
    # If all seasons are unknown, create dummy seasons based on date
    if all(season == 'Unknown' for season in df['season']):
        print("All seasons unknown, creating seasons from dates")
        # Try to extract year from date
        df['season'] = df['date'].apply(lambda x: str(x).split('-')[0] if '-' in str(x) else 'Unknown')

    return df

def extract_team_stats(df):
    """Calculate team performance metrics per season"""
    # Create team stats DataFrame
    teams = pd.concat([df['team1'], df['team2']]).unique()
    seasons = df['season'].unique()

    team_stats = []

    for season in seasons:
        season_df = df[df['season'] == season]

        for team in teams:
            # Team matches in the season
            team_matches = season_df[(season_df['team1'] == team) | (season_df['team2'] == team)]

            if len(team_matches) == 0:
                continue

            # Team wins
            team_wins = len(season_df[season_df['winner'] == team])

            # Toss wins
            toss_wins = len(season_df[season_df['toss_winner'] == team])

            # Home matches
            home_matches = len(team_matches[team_matches['team1'] == team])

            # Away matches
            away_matches = len(team_matches[team_matches['team2'] == team])

            # Win rate
            win_rate = team_wins / len(team_matches) if len(team_matches) > 0 else 0

            # Toss win rate
            toss_win_rate = toss_wins / len(team_matches) if len(team_matches) > 0 else 0

            team_stats.append({
                'season': season,
                'team': team,
                'matches_played': len(team_matches),
                'wins': team_wins,
                'toss_wins': toss_wins,
                'home_matches': home_matches,
                'away_matches': away_matches,
                'win_rate': win_rate,
                'toss_win_rate': toss_win_rate
            })

    return pd.DataFrame(team_stats)

def calculate_head_to_head(df):
    """Calculate head-to-head statistics between teams"""
    teams = pd.concat([df['team1'], df['team2']]).unique()

    h2h_stats = []

    for team1 in teams:
        for team2 in teams:
            if team1 == team2:
                continue

            # Matches between the two teams
            matches = df[((df['team1'] == team1) & (df['team2'] == team2)) |
                         ((df['team1'] == team2) & (df['team2'] == team1))]

            if len(matches) == 0:
                continue

            # Team1 wins against team2
            team1_wins = len(matches[matches['winner'] == team1])

            # Team2 wins against team1
            team2_wins = len(matches[matches['winner'] == team2])

            # Win rate of team1 against team2
            team1_win_rate = team1_wins / len(matches) if len(matches) > 0 else 0

            h2h_stats.append({
                'team1': team1,
                'team2': team2,
                'matches_played': len(matches),
                'team1_wins': team1_wins,
                'team2_wins': team2_wins,
                'team1_win_rate': team1_win_rate
            })

    return pd.DataFrame(h2h_stats)

def process_player_data():
    """Process player statistics from HTML files"""
    from bs4 import BeautifulSoup

    # Process batting records
    try:
        with open("/content/drive/MyDrive/IPL_Prediction_Model/data/ipl_batting_records.html", 'r') as f:
            batting_html = f.read()

        batting_soup = BeautifulSoup(batting_html, 'html.parser')
        batting_table = batting_soup.find('table', class_='engineTable')

        batting_records = []

        if batting_table:
            rows = batting_table.find_all('tr')
            headers = [th.text.strip() for th in rows[0].find_all('th')]

            for row in rows[1:]:
                cols = row.find_all('td')
                if cols:
                    batting_records.append({
                        headers[i]: col.text.strip()
                        for i, col in enumerate(cols) if i < len(headers)
                    })
    except:
        batting_records = []

    # Process bowling records
    try:
        with open("/content/drive/MyDrive/IPL_Prediction_Model/data/ipl_bowling_records.html", 'r') as f:
            bowling_html = f.read()

        bowling_soup = BeautifulSoup(bowling_html, 'html.parser')
        bowling_table = bowling_soup.find('table', class_='engineTable')

        bowling_records = []

        if bowling_table:
            rows = bowling_table.find_all('tr')
            headers = [th.text.strip() for th in rows[0].find_all('th')]

            for row in rows[1:]:
                cols = row.find_all('td')
                if cols:
                    bowling_records.append({
                        headers[i]: col.text.strip()
                        for i, col in enumerate(cols) if i < len(headers)
                    })
    except:
        bowling_records = []

    return pd.DataFrame(batting_records), pd.DataFrame(bowling_records)

def create_model_features(matches_df, team_stats_df, h2h_df):
    """Create feature dataset for predictive modeling"""
    model_data = []

    for _, match in matches_df.iterrows():
        if match['winner'] in ['no result', 'tie', 'Unknown']:
            continue

        team1 = match['team1']
        team2 = match['team2']
        season = match['season']

        # Get team stats for the season
        team1_stats = team_stats_df[(team_stats_df['team'] == team1) &
                                    (team_stats_df['season'] == season)]
        team2_stats = team_stats_df[(team_stats_df['team'] == team2) &
                                    (team_stats_df['season'] == season)]

        # Skip if team stats are not available
        if len(team1_stats) == 0 or len(team2_stats) == 0:
            continue

        # Get head-to-head stats
        h2h_stats = h2h_df[(h2h_df['team1'] == team1) & (h2h_df['team2'] == team2)]

        if len(h2h_stats) == 0:
            h2h_stats = h2h_df[(h2h_df['team1'] == team2) & (h2h_df['team2'] == team1)]
            if len(h2h_stats) > 0:
                # Swap team1 and team2 stats
                h2h_stats = h2h_stats.rename(columns={
                    'team1_wins': 'team2_wins',
                    'team2_wins': 'team1_wins',
                    'team1_win_rate': 'team2_win_rate'
                })
                h2h_stats['team1_win_rate'] = 1 - h2h_stats['team2_win_rate']

        # Default h2h values if not available
        h2h_matches_played = h2h_stats['matches_played'].values[0] if len(h2h_stats) > 0 else 0
        h2h_team1_win_rate = h2h_stats['team1_win_rate'].values[0] if len(h2h_stats) > 0 else 0.5

        # Create feature record
        record = {
            'match_id': match['match_id'],
            'season': season,
            'team1': team1,
            'team2': team2,
            'venue': match['venue'],
            'city': match['city'],
            'toss_winner': match['toss_winner'],
            'toss_decision': match['toss_decision'],

            # Team 1 stats
            'team1_matches_played': team1_stats['matches_played'].values[0],
            'team1_wins': team1_stats['wins'].values[0],
            'team1_win_rate': team1_stats['win_rate'].values[0],
            'team1_toss_win_rate': team1_stats['toss_win_rate'].values[0],

            # Team 2 stats
            'team2_matches_played': team2_stats['matches_played'].values[0],
            'team2_wins': team2_stats['wins'].values[0],
            'team2_win_rate': team2_stats['win_rate'].values[0],
            'team2_toss_win_rate': team2_stats['toss_win_rate'].values[0],

            # Head-to-head stats
            'h2h_matches_played': h2h_matches_played,
            'h2h_team1_win_rate': h2h_team1_win_rate,

            # Is team1 toss winner?
            'is_team1_toss_winner': 1 if match['toss_winner'] == team1 else 0,

            # Target variable
            'team1_win': 1 if match['winner'] == team1 else 0
        }

        model_data.append(record)

    return pd.DataFrame(model_data)

# Process match data
matches_df = process_match_data()
print("Original matches_df seasons:", matches_df['season'].unique())

# Fix seasons if they're all Unknown
if all(season == 'Unknown' for season in matches_df['season']):
    print("All seasons unknown, creating seasons from dates")
    # Try to extract year from date
    matches_df['season'] = matches_df['date'].apply(lambda x: str(x).split('-')[0] if '-' in str(x) else 'Unknown')
    print("After fix - matches_df seasons:", matches_df['season'].unique())

matches_df.to_csv("/content/drive/MyDrive/IPL_Prediction_Model/data/matches.csv", index=False)

# Get team statistics
team_stats_df = extract_team_stats(matches_df)
team_stats_df.to_csv("/content/drive/MyDrive/IPL_Prediction_Model/data/team_stats.csv", index=False)

# Get head-to-head statistics
h2h_df = calculate_head_to_head(matches_df)
h2h_df.to_csv("/content/drive/MyDrive/IPL_Prediction_Model/data/head_to_head.csv", index=False)

# Process player data
batting_df, bowling_df = process_player_data()
batting_df.to_csv("/content/drive/MyDrive/IPL_Prediction_Model/data/batting_records.csv", index=False)
bowling_df.to_csv("/content/drive/MyDrive/IPL_Prediction_Model/data/bowling_records.csv", index=False)

# Create model features
model_df = create_model_features(matches_df, team_stats_df, h2h_df)

# Print some diagnostics
print("Season values:", model_df['season'].unique())
print("Total samples:", len(model_df))

# Convert season to numeric if needed
model_df['season'] = pd.to_numeric(model_df['season'], errors='coerce')
model_df = model_df.dropna(subset=['season'])

print("After conversion - Season values:", model_df['season'].unique())
print("After conversion - Total samples:", len(model_df))

model_df.to_csv("/content/drive/MyDrive/IPL_Prediction_Model/data/model_features.csv", index=False)

# Feature definition
features = [
    'team1_matches_played', 'team1_wins', 'team1_win_rate', 'team1_toss_win_rate',
    'team2_matches_played', 'team2_wins', 'team2_win_rate', 'team2_toss_win_rate',
    'h2h_matches_played', 'h2h_team1_win_rate', 'is_team1_toss_winner'
]

categorical_features = ['team1', 'team2', 'venue', 'city', 'toss_decision']

# Check if we have 2023 data
has_2023 = 2023 in model_df['season'].unique()
print(f"Has 2023 data: {has_2023}")

# Train-test split
if has_2023:
    # Use 2008-2022 for training, 2023 for testing
    train_data = model_df[model_df['season'] <= 2022]
    test_data = model_df[model_df['season'] == 2023]
else:
    # Use 80-20 split
    train_size = int(0.8 * len(model_df))
    train_data = model_df.iloc[:train_size]
    test_data = model_df.iloc[train_size:]

print(f"Training data size: {len(train_data)}")
print(f"Testing data size: {len(test_data)}")

X_train = train_data[features + categorical_features]
y_train = train_data['team1_win']

X_test = test_data[features + categorical_features]
y_test = test_data['team1_win']

# CHUNK 7
# Preprocessing pipeline
categorical_transformer = Pipeline(steps=[
    ('onehot', OneHotEncoder(handle_unknown='ignore'))
])

numerical_transformer = Pipeline(steps=[
    ('scaler', StandardScaler())
])

preprocessor = ColumnTransformer(
    transformers=[
        ('num', numerical_transformer, features),
        ('cat', categorical_transformer, categorical_features)
    ],
    remainder='drop'
)

# Define models
models = {
    'RandomForest': Pipeline(steps=[
        ('preprocessor', preprocessor),
        ('classifier', RandomForestClassifier(n_estimators=100, random_state=42))
    ]),

    'XGBoost': Pipeline(steps=[
        ('preprocessor', preprocessor),
        ('classifier', xgb.XGBClassifier(n_estimators=100, random_state=42))
    ]),

    'CatBoost': Pipeline(steps=[
        ('preprocessor', preprocessor),
        ('classifier', CatBoostClassifier(iterations=100, random_state=42, verbose=0))
    ])
}

# Train models
for name, model in models.items():
    print(f"Training {name}...")
    model.fit(X_train, y_train)

    # Save model
    import joblib
    joblib.dump(model, f"/content/drive/MyDrive/IPL_Prediction_Model/models/{name}.pkl")

# Evaluate models
results = {}

for name, model in models.items():
    # Predictions on test set
    y_pred = model.predict(X_test)

    # Accuracy
    accuracy = accuracy_score(y_test, y_pred)

    # Classification report
    report = classification_report(y_test, y_pred, output_dict=True)

    # Confusion matrix
    cm = confusion_matrix(y_test, y_pred)

    results[name] = {
        'accuracy': accuracy,
        'report': report,
        'confusion_matrix': cm
    }

    print(f"{name} Accuracy: {accuracy:.4f}")
    print(f"{name} Classification Report:")
    print(classification_report(y_test, y_pred))

    # Plot confusion matrix
    plt.figure(figsize=(8, 6))
    sns.heatmap(cm, annot=True, fmt='d', cmap='Blues',
                xticklabels=['Team 2 Win', 'Team 1 Win'],
                yticklabels=['Team 2 Win', 'Team 1 Win'])
    plt.xlabel('Predicted')
    plt.ylabel('Actual')
    plt.title(f'Confusion Matrix - {name}')
    plt.savefig(f"/content/drive/MyDrive/IPL_Prediction_Model/results/{name}_confusion_matrix.png")
    plt.close()

# Find best model
best_model_name = max(results, key=lambda x: results[x]['accuracy'])
best_model = models[best_model_name]
best_accuracy = results[best_model_name]['accuracy']

print(f"Best Model: {best_model_name}")
print(f"Best Accuracy: {best_accuracy:.4f}")

# Hyperparameter Tuning for Best Model
if best_model_name == 'RandomForest':
    param_grid = {
        'classifier__n_estimators': [100, 200, 300],
        'classifier__max_depth': [None, 10, 20, 30],
        'classifier__min_samples_split': [2, 5, 10],
        'classifier__min_samples_leaf': [1, 2, 4]
    }
elif best_model_name == 'XGBoost':
    param_grid = {
        'classifier__n_estimators': [100, 200, 300],
        'classifier__learning_rate': [0.01, 0.1, 0.2],
        'classifier__max_depth': [3, 5, 7]
    }
else:  # CatBoost
    param_grid = {
        'classifier__iterations': [100, 200, 300],
        'classifier__learning_rate': [0.01, 0.1, 0.2],
        'classifier__depth': [4, 6, 8]
    }

# Grid search
grid_search = GridSearchCV(best_model, param_grid, cv=5, scoring='accuracy')
grid_search.fit(X_train, y_train)

print("Best Parameters:", grid_search.best_params_)
print("Best Cross-Validation Score:", grid_search.best_score_)

# Save tuned model
tuned_model = grid_search.best_estimator_
import joblib
joblib.dump(tuned_model, f"/content/drive/MyDrive/IPL_Prediction_Model/models/tuned_{best_model_name}.pkl")

# Evaluate tuned model
y_pred_tuned = tuned_model.predict(X_test)
tuned_accuracy = accuracy_score(y_test, y_pred_tuned)

print(f"Tuned {best_model_name} Accuracy: {tuned_accuracy:.4f}")
print(f"Tuned {best_model_name} Classification Report:")
print(classification_report(y_test, y_pred_tuned))

def prepare_ipl_2024_data():
    """Create a DataFrame for 2024 IPL matches"""
    # We should get the actual 2024 schedule and team info
    # For now, let's create a placeholder

    teams_2024 = [
        'Mumbai Indians',
        'Chennai Super Kings',
        'Royal Challengers Bangalore',
        'Kolkata Knight Riders',
        'Delhi Capitals',
        'Punjab Kings',
        'Rajasthan Royals',
        'Sunrisers Hyderabad',
        'Gujarat Titans',
        'Lucknow Super Giants'
    ]

    # Calculate team stats from 2023 season
    team_stats_2023 = team_stats_df[team_stats_df['season'] == 2023]

    # Create dummy schedule
    # In a real scenario, we would get the actual IPL 2024 schedule
    matches_2024 = []

    # Generate all possible team combinations
    import itertools
    team_combinations = list(itertools.combinations(teams_2024, 2))

    # Create matches (just an example, not the real schedule)
    for i, (team1, team2) in enumerate(team_combinations):
        matches_2024.append({
            'match_id': f'2024_{i+1}',
            'season': 2024,
            'team1': team1,
            'team2': team2,
            'venue': 'To be determined',
            'city': 'To be determined',
            'toss_winner': None,  # Will be known only before the match
            'toss_decision': None  # Will be known only before the match
        })

    # Create features for each match
    prediction_data = []

    for match in matches_2024:
        team1 = match['team1']
        team2 = match['team2']

        # Get team stats from 2023
        team1_stats = team_stats_2023[team_stats_2023['team'] == team1]
        team2_stats = team_stats_2023[team_stats_2023['team'] == team2]

        # Skip if team stats are not available
        if len(team1_stats) == 0 or len(team2_stats) == 0:
            continue

        # Get head-to-head stats
        h2h_stats = h2h_df[(h2h_df['team1'] == team1) & (h2h_df['team2'] == team2)]

        if len(h2h_stats) == 0:
            h2h_stats = h2h_df[(h2h_df['team1'] == team2) & (h2h_df['team2'] == team1)]
            if len(h2h_stats) > 0:
                # Swap team1 and team2 stats
                h2h_stats = h2h_stats.rename(columns={
                    'team1_wins': 'team2_wins',
                    'team2_wins': 'team1_wins',
                    'team1_win_rate': 'team2_win_rate'
                })
                h2h_stats['team1_win_rate'] = 1 - h2h_stats['team2_win_rate']

        # Default h2h values if not available
        h2h_matches_played = h2h_stats['matches_played'].values[0] if len(h2h_stats) > 0 else 0
        h2h_team1_win_rate = h2h_stats['team1_win_rate'].values[0] if len(h2h_stats) > 0 else 0.5

        # Create feature record
        # We'll create two versions - one for each toss outcome
        for toss_winner in [team1, team2]:
            for toss_decision in ['bat', 'field']:
                record = {
                    'match_id': match['match_id'],
                    'season': 2024,
                    'team1': team1,
                    'team2': team2,
                    'venue': match['venue'],
                    'city': match['city'],
                    'toss_winner': toss_winner,
                    'toss_decision': toss_decision,

                    # Team 1 stats
                    'team1_matches_played': team1_stats['matches_played'].values[0],
                    'team1_wins': team1_stats['wins'].values[0],
                    'team1_win_rate': team1_stats['win_rate'].values[0],
                    'team1_toss_win_rate': team1_stats['toss_win_rate'].values[0],

                    # Team 2 stats
                    'team2_matches_played': team2_stats['matches_played'].values[0],
                    'team2_wins': team2_stats['wins'].values[0],
                    'team2_win_rate': team2_stats['win_rate'].values[0],
                    'team2_toss_win_rate': team2_stats['toss_win_rate'].values[0],

                    # Head-to-head stats
                    'h2h_matches_played': h2h_matches_played,
                    'h2h_team1_win_rate': h2h_team1_win_rate,

                    # Is team1 toss winner?
                    'is_team1_toss_winner': 1 if toss_winner == team1 else 0,
                }

                prediction_data.append(record)

    return pd.DataFrame(prediction_data)

# Prepare 2024 prediction data
ipl_2024_data = prepare_ipl_2024_data()
ipl_2024_data.to_csv("/content/drive/MyDrive/IPL_Prediction_Model/data/ipl_2024_prediction_data.csv", index=False)

def predict_match(model, team1, team2, venue, city, toss_winner, toss_decision):
   """Predict the outcome of a match between team1 and team2"""
   # Get team stats from 2023 season
   team_stats_2023 = team_stats_df[team_stats_df['season'] == 2023]

   # Print available teams to debug
   print(f"Available teams in 2023: {team_stats_2023['team'].unique()}")

   team1_stats = team_stats_2023[team_stats_2023['team'] == team1]
   team2_stats = team_stats_2023[team_stats_2023['team'] == team2]

   # Check if team stats are available
   if len(team1_stats) == 0:
       print(f"No stats available for {team1}")
   if len(team2_stats) == 0:
       print(f"No stats available for {team2}")

   # Skip if team stats are not available
   if len(team1_stats) == 0 or len(team2_stats) == 0:
       # Use average stats instead
       avg_matches = team_stats_2023['matches_played'].mean()
       avg_wins = team_stats_2023['wins'].mean()
       avg_win_rate = team_stats_2023['win_rate'].mean()
       avg_toss_win_rate = team_stats_2023['toss_win_rate'].mean()

       if len(team1_stats) == 0:
           team1_stats = pd.DataFrame([{
               'team': team1,
               'matches_played': avg_matches,
               'wins': avg_wins,
               'win_rate': avg_win_rate,
               'toss_win_rate': avg_toss_win_rate
           }])

       if len(team2_stats) == 0:
           team2_stats = pd.DataFrame([{
               'team': team2,
               'matches_played': avg_matches,
               'wins': avg_wins,
               'win_rate': avg_win_rate,
               'toss_win_rate': avg_toss_win_rate
           }])

   # Get head-to-head stats
   h2h_stats = h2h_df[(h2h_df['team1'] == team1) & (h2h_df['team2'] == team2)]

   if len(h2h_stats) == 0:
       h2h_stats = h2h_df[(h2h_df['team1'] == team2) & (h2h_df['team2'] == team1)]
       if len(h2h_stats) > 0:
           # Swap team1 and team2 stats
           h2h_stats = h2h_stats.rename(columns={
               'team1_wins': 'team2_wins',
               'team2_wins': 'team1_wins',
               'team1_win_rate': 'team2_win_rate'
           })
           h2h_stats['team1_win_rate'] = 1 - h2h_stats['team2_win_rate']

   # Default h2h values if not available
   if len(h2h_stats) == 0:
       h2h_matches_played = 0
       h2h_team1_win_rate = 0.5  # Equal chance if no previous matches
   else:
       h2h_matches_played = h2h_stats['matches_played'].values[0]
       h2h_team1_win_rate = h2h_stats['team1_win_rate'].values[0]

   # Create feature record
   record = pd.DataFrame([{
       'team1': team1,
       'team2': team2,
       'venue': venue,
       'city': city,
       'toss_winner': toss_winner,
       'toss_decision': toss_decision,

       # Team 1 stats
       'team1_matches_played': team1_stats['matches_played'].values[0],
       'team1_wins': team1_stats['wins'].values[0],
       'team1_win_rate': team1_stats['win_rate'].values[0],
       'team1_toss_win_rate': team1_stats['toss_win_rate'].values[0],

       # Team 2 stats
       'team2_matches_played': team2_stats['matches_played'].values[0],
       'team2_wins': team2_stats['wins'].values[0],
       'team2_win_rate': team2_stats['win_rate'].values[0],
       'team2_toss_win_rate': team2_stats['toss_win_rate'].values[0],

       # Head-to-head stats
       'h2h_matches_played': h2h_matches_played,
       'h2h_team1_win_rate': h2h_team1_win_rate,

       # Is team1 toss winner?
       'is_team1_toss_winner': 1 if toss_winner == team1 else 0,
   }])

   # Make prediction
   try:
       prediction = model.predict(record)[0]
       proba = model.predict_proba(record)[0]

       if prediction == 1:
           return f"{team1} win with {proba[1]*100:.2f}% probability"
       else:
           return f"{team2} win with {proba[0]*100:.2f}% probability"
   except Exception as e:
       print(f"Error making prediction: {e}")
       return f"Unable to predict {team1} vs {team2} match"

# Example usage
print(predict_match(
   tuned_model,
   'Mumbai Indians',
   'Chennai Super Kings',
   'Wankhede Stadium',
   'Mumbai',
   'Mumbai Indians',
   'bat'
))

# After processing match data
matches_df = process_match_data()
print("Available seasons in matches_df:", matches_df['season'].unique())
print("Total matches:", len(matches_df))

# Check formatting of seasons (string vs int)
print("Season data type:", type(matches_df['season'].iloc[0]))

def extract_team_stats(df):
    """Calculate team performance metrics per season"""
    # Convert season to string for consistent comparison
    df = df.copy()
    df['season'] = df['season'].astype(str)

    # Continue with original function...

# Check if 2023 data exists
matches_2023 = matches_df[matches_df['season'] == '2023']
print("2023 matches found:", len(matches_2023))
print("2023 teams:", matches_2023['team1'].unique(), matches_2023['team2'].unique())

def extract_team_stats(df):
    """Calculate team performance metrics per season"""
    # Create team stats DataFrame
    teams = pd.concat([df['team1'], df['team2']]).unique()
    seasons = df['season'].unique()

    team_stats = []

    for season in seasons:
        season_df = df[df['season'] == season]

        for team in teams:
            # Team matches in the season
            team_matches = season_df[(season_df['team1'] == team) | (season_df['team2'] == team)]

            if len(team_matches) == 0:
                continue

            # Team wins
            team_wins = len(season_df[season_df['winner'] == team])

            # Toss wins
            toss_wins = len(season_df[season_df['toss_winner'] == team])

            # Home matches
            home_matches = len(team_matches[team_matches['team1'] == team])

            # Away matches
            away_matches = len(team_matches[team_matches['team2'] == team])

            # Win rate
            win_rate = team_wins / len(team_matches) if len(team_matches) > 0 else 0

            # Toss win rate
            toss_win_rate = toss_wins / len(team_matches) if len(team_matches) > 0 else 0

            team_stats.append({
                'season': season,
                'team': team,
                'matches_played': len(team_matches),
                'wins': team_wins,
                'toss_wins': toss_wins,
                'home_matches': home_matches,
                'away_matches': away_matches,
                'win_rate': win_rate,
                'toss_win_rate': toss_win_rate
            })

    return pd.DataFrame(team_stats)

# Run again
team_stats_df = extract_team_stats(matches_df)
print("Seasons in team_stats:", team_stats_df['season'].unique())
print("Teams in 2023:", team_stats_df[team_stats_df['season'] == '2023']['team'].unique())
print("Total team stats entries:", len(team_stats_df))

# Check if model_df exists
if 'model_df' in locals():
    print("Model features already created")
    print("Number of features:", len(model_df.columns))
    print("Number of samples:", len(model_df))
    print("Seasons available:", model_df['season'].unique())
else:
    print("Model features not created yet, running create_model_features...")
    model_df = create_model_features(matches_df, team_stats_df, h2h_df)
    model_df.to_csv("/content/drive/MyDrive/IPL_Prediction_Model/data/model_features.csv", index=False)
    print("Model features created with", len(model_df), "samples")

# Preprocessing pipeline
categorical_transformer = Pipeline(steps=[
    ('onehot', OneHotEncoder(handle_unknown='ignore'))
])

numerical_transformer = Pipeline(steps=[
    ('scaler', StandardScaler())
])

preprocessor = ColumnTransformer(
    transformers=[
        ('num', numerical_transformer, features),
        ('cat', categorical_transformer, categorical_features)
    ],
    remainder='drop'
)

# Define models
models = {
    'RandomForest': Pipeline(steps=[
        ('preprocessor', preprocessor),
        ('classifier', RandomForestClassifier(n_estimators=100, random_state=42))
    ]),

    'XGBoost': Pipeline(steps=[
        ('preprocessor', preprocessor),
        ('classifier', xgb.XGBClassifier(n_estimators=100, random_state=42))
    ]),

    'CatBoost': Pipeline(steps=[
        ('preprocessor', preprocessor),
        ('classifier', CatBoostClassifier(iterations=100, random_state=42, verbose=0))
    ])
}

# Train models
for name, model in models.items():
    print(f"Training {name}...")
    model.fit(X_train, y_train)

    # Save model
    import joblib
    joblib.dump(model, f"/content/drive/MyDrive/IPL_Prediction_Model/models/{name}.pkl")

# Evaluate models
results = {}

for name, model in models.items():
    # Predictions on test set
    y_pred = model.predict(X_test)

    # Accuracy
    accuracy = accuracy_score(y_test, y_pred)

    # Classification report
    report = classification_report(y_test, y_pred, output_dict=True)

    # Confusion matrix
    cm = confusion_matrix(y_test, y_pred)

    results[name] = {
        'accuracy': accuracy,
        'report': report,
        'confusion_matrix': cm
    }

    print(f"{name} Accuracy: {accuracy:.4f}")
    print(f"{name} Classification Report:")
    print(classification_report(y_test, y_pred))

    # Plot confusion matrix
    plt.figure(figsize=(8, 6))
    sns.heatmap(cm, annot=True, fmt='d', cmap='Blues',
                xticklabels=['Team 2 Win', 'Team 1 Win'],
                yticklabels=['Team 2 Win', 'Team 1 Win'])
    plt.xlabel('Predicted')
    plt.ylabel('Actual')
    plt.title(f'Confusion Matrix - {name}')
    plt.savefig(f"/content/drive/MyDrive/IPL_Prediction_Model/results/{name}_confusion_matrix.png")
    plt.close()

# Find best model
best_model_name = max(results, key=lambda x: results[x]['accuracy'])
best_model = models[best_model_name]
best_accuracy = results[best_model_name]['accuracy']

print(f"Best Model: {best_model_name}")
print(f"Best Accuracy: {best_accuracy:.4f}")

# Hyperparameter Tuning for Best Model
if best_model_name == 'RandomForest':
    param_grid = {
        'classifier__n_estimators': [100, 200, 300],
        'classifier__max_depth': [None, 10, 20, 30],
        'classifier__min_samples_split': [2, 5, 10],
        'classifier__min_samples_leaf': [1, 2, 4]
    }
elif best_model_name == 'XGBoost':
    param_grid = {
        'classifier__n_estimators': [100, 200, 300],
        'classifier__learning_rate': [0.01, 0.1, 0.2],
        'classifier__max_depth': [3, 5, 7]
    }
else:  # CatBoost
    param_grid = {
        'classifier__iterations': [100, 200, 300],
        'classifier__learning_rate': [0.01, 0.1, 0.2],
        'classifier__depth': [4, 6, 8]
    }

# Grid search
grid_search = GridSearchCV(best_model, param_grid, cv=5, scoring='accuracy')
grid_search.fit(X_train, y_train)

print("Best Parameters:", grid_search.best_params_)
print("Best Cross-Validation Score:", grid_search.best_score_)

# Save tuned model
tuned_model = grid_search.best_estimator_
import joblib
joblib.dump(tuned_model, f"/content/drive/MyDrive/IPL_Prediction_Model/models/tuned_{best_model_name}.pkl")

# Evaluate tuned model
y_pred_tuned = tuned_model.predict(X_test)
tuned_accuracy = accuracy_score(y_test, y_pred_tuned)

print(f"Tuned {best_model_name} Accuracy: {tuned_accuracy:.4f}")
print(f"Tuned {best_model_name} Classification Report:")
print(classification_report(y_test, y_pred_tuned))

def prepare_ipl_2024_data():
    """Create a DataFrame for 2024 IPL matches"""
    # We should get the actual 2024 schedule and team info
    # For now, let's create a placeholder

    teams_2024 = [
        'Mumbai Indians',
        'Chennai Super Kings',
        'Royal Challengers Bangalore',
        'Kolkata Knight Riders',
        'Delhi Capitals',
        'Punjab Kings',
        'Rajasthan Royals',
        'Sunrisers Hyderabad',
        'Gujarat Titans',
        'Lucknow Super Giants'
    ]

    # Calculate team stats from 2023 season
    team_stats_2023 = team_stats_df[team_stats_df['season'] == 2023]

    # Create dummy schedule
    # In a real scenario, we would get the actual IPL 2024 schedule
    matches_2024 = []

    # Generate all possible team combinations
    import itertools
    team_combinations = list(itertools.combinations(teams_2024, 2))

    # Create matches (just an example, not the real schedule)
    for i, (team1, team2) in enumerate(team_combinations):
        matches_2024.append({
            'match_id': f'2024_{i+1}',
            'season': 2024,
            'team1': team1,
            'team2': team2,
            'venue': 'To be determined',
            'city': 'To be determined',
            'toss_winner': None,  # Will be known only before the match
            'toss_decision': None  # Will be known only before the match
        })

    # Create features for each match
    prediction_data = []

    for match in matches_2024:
        team1 = match['team1']
        team2 = match['team2']

        # Get team stats from 2023
        team1_stats = team_stats_2023[team_stats_2023['team'] == team1]
        team2_stats = team_stats_2023[team_stats_2023['team'] == team2]

        # Skip if team stats are not available
        if len(team1_stats) == 0 or len(team2_stats) == 0:
            continue

        # Get head-to-head stats
        h2h_stats = h2h_df[(h2h_df['team1'] == team1) & (h2h_df['team2'] == team2)]

        if len(h2h_stats) == 0:
            h2h_stats = h2h_df[(h2h_df['team1'] == team2) & (h2h_df['team2'] == team1)]
            if len(h2h_stats) > 0:
                # Swap team1 and team2 stats
                h2h_stats = h2h_stats.rename(columns={
                    'team1_wins': 'team2_wins',
                    'team2_wins': 'team1_wins',
                    'team1_win_rate': 'team2_win_rate'
                })
                h2h_stats['team1_win_rate'] = 1 - h2h_stats['team2_win_rate']

        # Default h2h values if not available
        h2h_matches_played = h2h_stats['matches_played'].values[0] if len(h2h_stats) > 0 else 0
        h2h_team1_win_rate = h2h_stats['team1_win_rate'].values[0] if len(h2h_stats) > 0 else 0.5

        # Create feature record
        # We'll create two versions - one for each toss outcome
        for toss_winner in [team1, team2]:
            for toss_decision in ['bat', 'field']:
                record = {
                    'match_id': match['match_id'],
                    'season': 2024,
                    'team1': team1,
                    'team2': team2,
                    'venue': match['venue'],
                    'city': match['city'],
                    'toss_winner': toss_winner,
                    'toss_decision': toss_decision,

                    # Team 1 stats
                    'team1_matches_played': team1_stats['matches_played'].values[0],
                    'team1_wins': team1_stats['wins'].values[0],
                    'team1_win_rate': team1_stats['win_rate'].values[0],
                    'team1_toss_win_rate': team1_stats['toss_win_rate'].values[0],

                    # Team 2 stats
                    'team2_matches_played': team2_stats['matches_played'].values[0],
                    'team2_wins': team2_stats['wins'].values[0],
                    'team2_win_rate': team2_stats['win_rate'].values[0],
                    'team2_toss_win_rate': team2_stats['toss_win_rate'].values[0],

                    # Head-to-head stats
                    'h2h_matches_played': h2h_matches_played,
                    'h2h_team1_win_rate': h2h_team1_win_rate,

                    # Is team1 toss winner?
                    'is_team1_toss_winner': 1 if toss_winner == team1 else 0,
                }

                prediction_data.append(record)

    return pd.DataFrame(prediction_data)

# Prepare 2024 prediction data
ipl_2024_data = prepare_ipl_2024_data()
ipl_2024_data.to_csv("/content/drive/MyDrive/IPL_Prediction_Model/data/ipl_2024_prediction_data.csv", index=False)

def predict_match(model, team1, team2, venue, city, toss_winner, toss_decision):
    """Predict the outcome of a match between team1 and team2"""
    # Debug prints
    print(f"Looking for stats for {team1} and {team2}")

    # Get team stats from 2023 season
    team_stats_2023 = team_stats_df[team_stats_df['season'] == '2023']  # Note: string comparison
    print(f"Found {len(team_stats_2023)} team entries for 2023")

    team1_stats = team_stats_2023[team_stats_2023['team'] == team1]
    team2_stats = team_stats_2023[team_stats_2023['team'] == team2]

    print(f"Stats for {team1}: {len(team1_stats)} entries")
    print(f"Stats for {team2}: {len(team2_stats)} entries")

    # Skip if team stats are not available
    if len(team1_stats) == 0 or len(team2_stats) == 0:
        # Use average stats instead
        avg_matches = team_stats_2023['matches_played'].mean()
        avg_wins = team_stats_2023['wins'].mean()
        avg_win_rate = team_stats_2023['win_rate'].mean()
        avg_toss_win_rate = team_stats_2023['toss_win_rate'].mean()

        if len(team1_stats) == 0:
            print(f"Using average stats for {team1}")
            team1_stats = pd.DataFrame([{
                'team': team1,
                'matches_played': avg_matches,
                'wins': avg_wins,
                'win_rate': avg_win_rate,
                'toss_win_rate': avg_toss_win_rate
            }])

        if len(team2_stats) == 0:
            print(f"Using average stats for {team2}")
            team2_stats = pd.DataFrame([{
                'team': team2,
                'matches_played': avg_matches,
                'wins': avg_wins,
                'win_rate': avg_win_rate,
                'toss_win_rate': avg_toss_win_rate
            }])

    # Get head-to-head stats
    h2h_stats = h2h_df[(h2h_df['team1'] == team1) & (h2h_df['team2'] == team2)]

    if len(h2h_stats) == 0:
        h2h_stats = h2h_df[(h2h_df['team1'] == team2) & (h2h_df['team2'] == team1)]
        if len(h2h_stats) > 0:
            # Swap team1 and team2 stats
            h2h_stats = h2h_stats.rename(columns={
                'team1_wins': 'team2_wins',
                'team2_wins': 'team1_wins',
                'team1_win_rate': 'team2_win_rate'
            })
            h2h_stats['team1_win_rate'] = 1 - h2h_stats['team2_win_rate']

    # Default h2h values if not available
    if len(h2h_stats) == 0:
        h2h_matches_played = 0
        h2h_team1_win_rate = 0.5  # Equal chance if no previous matches
    else:
        h2h_matches_played = h2h_stats['matches_played'].values[0]
        h2h_team1_win_rate = h2h_stats['team1_win_rate'].values[0]

    # Create feature record
    record = pd.DataFrame([{
        'team1': team1,
        'team2': team2,
        'venue': venue,
        'city': city,
        'toss_winner': toss_winner,
        'toss_decision': toss_decision,

        # Team 1 stats
        'team1_matches_played': team1_stats['matches_played'].values[0],
        'team1_wins': team1_stats['wins'].values[0],
        'team1_win_rate': team1_stats['win_rate'].values[0],
        'team1_toss_win_rate': team1_stats['toss_win_rate'].values[0],

        # Team 2 stats
        'team2_matches_played': team2_stats['matches_played'].values[0],
        'team2_wins': team2_stats['wins'].values[0],
        'team2_win_rate': team2_stats['win_rate'].values[0],
        'team2_toss_win_rate': team2_stats['toss_win_rate'].values[0],

        # Head-to-head stats
        'h2h_matches_played': h2h_matches_played,
        'h2h_team1_win_rate': h2h_team1_win_rate,

        # Is team1 toss winner?
        'is_team1_toss_winner': 1 if toss_winner == team1 else 0,
    }])

    # Make prediction
    try:
        prediction = model.predict(record)[0]
        proba = model.predict_proba(record)[0]

        if prediction == 1:
            return f"{team1} win with {proba[1]*100:.2f}% probability"
        else:
            return f"{team2} win with {proba[0]*100:.2f}% probability"
    except Exception as e:
        print(f"Error making prediction: {e}")
        return f"Unable to predict {team1} vs {team2} match"

# Example usage
print(predict_match(
    tuned_model,
    'Mumbai Indians',
    'Chennai Super Kings',
    'Wankhede Stadium',
    'Mumbai',
    'Mumbai Indians',
    'bat'
))

# --- 10. Testing on IPL 2024 ---
# When IPL 2024 schedule is available, we'll load it and make predictions
def load_ipl_2024_schedule():
    """Load the actual IPL 2024 schedule when available"""
    # In a real scenario, we would scrape or load the actual schedule
    # For now, we'll create a placeholder

    # Format: match_id, date, team1, team2, venue, city
    schedule = [
        # Sample matches - to be replaced with actual schedule
        ('2024_01', '2024-03-22', 'Chennai Super Kings', 'Royal Challengers Bangalore', 'M. A. Chidambaram Stadium', 'Chennai'),
        ('2024_02', '2024-03-23', 'Punjab Kings', 'Delhi Capitals', 'Punjab Cricket Association Stadium', 'Mohali'),
        ('2024_03', '2024-03-23', 'Kolkata Knight Riders', 'Sunrisers Hyderabad', 'Eden Gardens', 'Kolkata'),
        # Add more matches as per the actual schedule
    ]

    return pd.DataFrame(schedule, columns=['match_id', 'date', 'team1', 'team2', 'venue', 'city'])

# Function to make predictions for IPL 2024
def predict_ipl_2024(model):
    """Make predictions for IPL 2024 matches"""
    schedule = load_ipl_2024_schedule()
    predictions = []

    for _, match in schedule.iterrows():
        team1 = match['team1']
        team2 = match['team2']
        venue = match['venue']
        city = match['city']

        # We don't know toss results yet, so we'll predict both scenarios
        # Team 1 wins toss and bats
        pred1 = predict_match(model, team1, team2, venue, city, team1, 'bat')
        # Team 1 wins toss and fields
        pred2 = predict_match(model, team1, team2, venue, city, team1, 'field')
        # Team 2 wins toss and bats
        pred3 = predict_match(model, team1, team2, venue, city, team2, 'bat')
        # Team 2 wins toss and fields
        pred4 = predict_match(model, team1, team2, venue, city, team2, 'field')

        predictions.append({
            'match_id': match['match_id'],
            'date': match['date'],
            'team1': team1,
            'team2': team2,
            'venue': venue,
            'city': city,
            'team1_toss_bat': pred1,
            'team1_toss_field': pred2,
            'team2_toss_bat': pred3,
            'team2_toss_field': pred4
        })

    return pd.DataFrame(predictions)

# Make predictions
ipl_2024_predictions = predict_ipl_2024(tuned_model)
ipl_2024_predictions.to_csv("/content/drive/MyDrive/IPL_Prediction_Model/results/ipl_2024_predictions.csv", index=False)

# --- 12. Visualize Results ---
def visualize_model_performance():
    """Visualize model performance metrics"""
    # Accuracy comparison
    model_names = list(results.keys()) + ['Tuned ' + best_model_name]
    accuracies = [results[name]['accuracy'] for name in results.keys()] + [tuned_accuracy]

    plt.figure(figsize=(10, 6))
    bars = plt.bar(model_names, accuracies, color=['blue', 'green', 'orange', 'red'])
    plt.axhline(y=0.85, color='r', linestyle='--', label='Target (85%)')

    # Add accuracy values on top of bars
    for bar, acc in zip(bars, accuracies):
        plt.text(bar.get_x() + bar.get_width()/2, bar.get_height() + 0.01,
                f'{acc:.2%}', ha='center', fontweight='bold')

    plt.xlabel('Model')
    plt.ylabel('Accuracy')
    plt.title('Model Accuracy Comparison')
    plt.ylim(0, 1.0)
    plt.legend()
    plt.tight_layout()
    plt.savefig("/content/drive/MyDrive/IPL_Prediction_Model/results/model_accuracy_comparison.png")
    plt.close()

    # Feature importance (for the best model)
    if hasattr(tuned_model.named_steps['classifier'], 'feature_importances_'):
        # Get feature names after preprocessing
        preprocessor = tuned_model.named_steps['preprocessor']
        feature_names = (
            features +
            preprocessor.transformers_[1][1].named_steps['onehot'].get_feature_names_out(categorical_features).tolist()
        )

        # Get feature importances
        importances = tuned_model.named_steps['classifier'].feature_importances_

        # Plot top 15 features
        indices = np.argsort(importances)[-15:]
        plt.figure(figsize=(12, 8))
        plt.barh(range(len(indices)), importances[indices], align='center')
        plt.yticks(range(len(indices)), [feature_names[i] for i in indices])
        plt.xlabel('Feature Importance')
        plt.title(f'Top 15 Feature Importances - {best_model_name}')
        plt.tight_layout()
        plt.savefig("/content/drive/MyDrive/IPL_Prediction_Model/results/feature_importance.png")
        plt.close()

def create_dashboard():
    """Create an HTML dashboard for IPL predictions"""
    html_content = """
    <!DOCTYPE html>
    <html>
    <head>
        <title>IPL 2024 Match Predictions</title>
        <style>
            body {{
                font-family: Arial, sans-serif;
                margin: 0;
                padding: 20px;
                background-color: #f5f5f5;
            }}
            .container {{
                max-width: 1200px;
                margin: 0 auto;
                background-color: white;
                padding: 20px;
                border-radius: 10px;
                box-shadow: 0 0 10px rgba(0,0,0,0.1);
            }}
            h1, h2 {{
                color: #0078d7;
            }}
            table {{
                width: 100%;
                border-collapse: collapse;
                margin-top: 20px;
            }}
            th, td {{
                padding: 12px;
                text-align: left;
                border-bottom: 1px solid #ddd;
            }}
            th {{
                background-color: #0078d7;
                color: white;
            }}
            tr:hover {{
                background-color: #f1f1f1;
            }}
            .team-logo {{
                width: 30px;
                height: 30px;
                margin-right: 10px;
                vertical-align: middle;
            }}
            .prediction {{
                font-weight: bold;
                color: #0078d7;
            }}
            .model-info {{
                margin-top: 20px;
                padding: 15px;
                background-color: #f9f9f9;
                border-radius: 5px;
            }}
            .footer {{
                margin-top: 30px;
                text-align: center;
                color: #666;
            }}
        </style>
    </head>
    <body>
        <div class="container">
            <h1>IPL 2024 Match Predictions</h1>

            <div class="model-info">
                <h2>Model Information</h2>
                <p><strong>Best Model:</strong> {model_name}</p>
                <p><strong>Accuracy:</strong> {accuracy:.2%}</p>
                <p><strong>Target:</strong> 85% accuracy, predicting at least 65 out of 74 matches correctly</p>
            </div>

            <h2>Match Predictions</h2>
            <table>
                <tr>
                    <th>Date</th>
                    <th>Match</th>
                    <th>Venue</th>
                    <th>Prediction (After Toss)</th>
                </tr>
                {table_rows}
            </table>

            <div class="footer">
                <p>© 2024 IPL Prediction Model - For educational purposes only</p>
            </div>
        </div>
    </body>
    </html>
    """

    # Get predictions
    predictions = pd.read_csv("/content/drive/MyDrive/IPL_Prediction_Model/results/ipl_2024_predictions.csv")

    # Generate table rows
    table_rows = ""
    for _, match in predictions.iterrows():
        table_rows += f"""
        <tr>
            <td>{match['date']}</td>
            <td>{match['team1']} vs {match['team2']}</td>
            <td>{match['venue']}, {match['city']}</td>
            <td>
                <p>If {match['team1']} wins toss & bats: <span class="prediction">{match['team1_toss_bat']}</span></p>
                <p>If {match['team1']} wins toss & fields: <span class="prediction">{match['team1_toss_field']}</span></p>
                <p>If {match['team2']} wins toss & bats: <span class="prediction">{match['team2_toss_bat']}</span></p>
                <p>If {match['team2']} wins toss & fields: <span class="prediction">{match['team2_toss_field']}</span></p>
            </td>
        </tr>
        """

    # Format HTML with model info
    html_content = html_content.format(
        model_name=f"Tuned {best_model_name}",
        accuracy=tuned_accuracy,
        table_rows=table_rows
    )

    # Save HTML file
    with open("/content/drive/MyDrive/IPL_Prediction_Model/results/ipl_2024_predictions_dashboard.html", "w") as f:
        f.write(html_content)

prediction = predict_match(
    tuned_model,
    'Kolkata Knight Riders',
    'Royal Challengers Bangalore',
    'Eden Gardens',
    'Kolkata',
    'Kolkata Knight Riders',  # Assuming KKR wins toss
    'bat'  # Assuming they choose to bat
)
print(prediction)

# Also try other toss scenarios
prediction2 = predict_match(
    tuned_model,
    'Kolkata Knight Riders',
    'Royal Challengers Bangalore',
    'Eden Gardens',
    'Kolkata',
    'Kolkata Knight Riders',
    'field'
)
print(prediction2)

prediction3 = predict_match(
    tuned_model,
    'Kolkata Knight Riders',
    'Royal Challengers Bangalore',
    'Eden Gardens',
    'Kolkata',
    'Royal Challengers Bangalore',
    'bat'
)
print(prediction3)

prediction4 = predict_match(
    tuned_model,
    'Kolkata Knight Riders',
    'Royal Challengers Bangalore',
    'Eden Gardens',
    'Kolkata',
    'Royal Challengers Bangalore',
    'field'
)
print(prediction4)

mi_csk = [
    predict_match(tuned_model, 'Mumbai Indians', 'Chennai Super Kings', 'Wankhede Stadium', 'Mumbai', 'Mumbai Indians', 'bat'),
    predict_match(tuned_model, 'Mumbai Indians', 'Chennai Super Kings', 'Wankhede Stadium', 'Mumbai', 'Mumbai Indians', 'field'),
    predict_match(tuned_model, 'Mumbai Indians', 'Chennai Super Kings', 'Wankhede Stadium', 'Mumbai', 'Chennai Super Kings', 'bat'),
    predict_match(tuned_model, 'Mumbai Indians', 'Chennai Super Kings', 'Wankhede Stadium', 'Mumbai', 'Chennai Super Kings', 'field')
]

for result in mi_csk:
    print(result)

gt_rr = [
    predict_match(tuned_model, 'Gujarat Titans', 'Rajasthan Royals', 'Narendra Modi Stadium', 'Ahmedabad', 'Gujarat Titans', 'bat'),
    predict_match(tuned_model, 'Gujarat Titans', 'Rajasthan Royals', 'Narendra Modi Stadium', 'Ahmedabad', 'Gujarat Titans', 'field'),
    predict_match(tuned_model, 'Gujarat Titans', 'Rajasthan Royals', 'Narendra Modi Stadium', 'Ahmedabad', 'Rajasthan Royals', 'bat'),
    predict_match(tuned_model, 'Gujarat Titans', 'Rajasthan Royals', 'Narendra Modi Stadium', 'Ahmedabad', 'Rajasthan Royals', 'field')
]

for result in gt_rr:
    print(result)

# List of upcoming matches
upcoming_matches = [
    ('Kolkata Knight Riders', 'Royal Challengers Bangalore', 'Eden Gardens', 'Kolkata'),
    ('Sunrisers Hyderabad', 'Rajasthan Royals', 'Rajiv Gandhi International Stadium', 'Hyderabad'),
    ('Chennai Super Kings', 'Mumbai Indians', 'M. A. Chidambaram Stadium', 'Chennai'),
    ('Delhi Capitals', 'Lucknow Super Giants', 'ACA-VDCA Cricket Stadium', 'Visakhapatnam'),
    ('Gujarat Titans', 'Punjab Kings', 'Narendra Modi Stadium', 'Ahmedabad'),
    ('Rajasthan Royals', 'Kolkata Knight Riders', 'Barsapara Cricket Stadium', 'Guwahati')
]

# Run predictions for each match
for team1, team2, venue, city in upcoming_matches:
    print(f"\n===== {team1} vs {team2} at {venue} =====")

    # Team 1 wins toss and bats
    pred1 = predict_match(tuned_model, team1, team2, venue, city, team1, 'bat')
    print(f"If {team1} wins toss & bats: {pred1}")

    # Team 1 wins toss and fields
    pred2 = predict_match(tuned_model, team1, team2, venue, city, team1, 'field')
    print(f"If {team1} wins toss & fields: {pred2}")

    # Team 2 wins toss and bats
    pred3 = predict_match(tuned_model, team1, team2, venue, city, team2, 'bat')
    print(f"If {team2} wins toss & bats: {pred3}")

    # Team 2 wins toss and fields
    pred4 = predict_match(tuned_model, team1, team2, venue, city, team2, 'field')
    print(f"If {team2} wins toss & fields: {pred4}")

# Create directories if they don't exist
import os
os.makedirs("/content/drive/MyDrive/IPL_Prediction_Model/data", exist_ok=True)

# Now create and save the data
import pandas as pd
import numpy as np

# Same player_data code as before...
player_data = [
    # Format: [id, name, role, country, batting_impact, bowling_impact, 2024_team, 2025_team]
    [1, 'Rohit Sharma', 'Batsman', 'India', 80, 10, 'Mumbai Indians', 'Mumbai Indians'],
    # Rest of player data...
]

# Create players dataframe
players_df = pd.DataFrame(player_data, columns=['player_id', 'name', 'role', 'country',
                                              'batting_impact', 'bowling_impact',
                                              'team_2024', 'team_2025'])

# Calculate overall impact
players_df['overall_impact'] = players_df['batting_impact'] + players_df['bowling_impact']

# Create team affiliations
# Rest of the code as before...

# Save to CSV
players_df.to_csv("/content/drive/MyDrive/IPL_Prediction_Model/data/players_manual.csv", index=False)
affiliations_df.to_csv("/content/drive/MyDrive/IPL_Prediction_Model/data/player_affiliations.csv", index=False)

# --- IPL 2025 Player Data (Manual Approach) ---
import pandas as pd
import numpy as np

# Create player database with 2024 and 2025 team affiliations
player_data = [
    # Format: [id, name, role, country, batting_impact, bowling_impact, 2024_team, 2025_team]
    [1, 'Rohit Sharma', 'Batsman', 'India', 80, 10, 'Mumbai Indians', 'Mumbai Indians'],
    [2, 'Hardik Pandya', 'All-rounder', 'India', 75, 65, 'Mumbai Indians', 'Mumbai Indians'],
    [3, 'Jasprit Bumrah', 'Bowler', 'India', 10, 95, 'Mumbai Indians', 'Mumbai Indians'],
    [4, 'MS Dhoni', 'Wicketkeeper', 'India', 65, 0, 'Chennai Super Kings', 'Chennai Super Kings'],
    [5, 'Ravindra Jadeja', 'All-rounder', 'India', 60, 75, 'Chennai Super Kings', 'Chennai Super Kings'],
    [6, 'Ruturaj Gaikwad', 'Batsman', 'India', 75, 0, 'Chennai Super Kings', 'Chennai Super Kings'],
    [7, 'Virat Kohli', 'Batsman', 'India', 90, 10, 'Royal Challengers Bangalore', 'Royal Challengers Bangalore'],
    [8, 'Glenn Maxwell', 'All-rounder', 'Australia', 80, 50, 'Royal Challengers Bangalore', 'Royal Challengers Bangalore'],
    [9, 'Mohammed Siraj', 'Bowler', 'India', 5, 80, 'Royal Challengers Bangalore', 'Royal Challengers Bangalore'],
    [10, 'Andre Russell', 'All-rounder', 'West Indies', 75, 70, 'Kolkata Knight Riders', 'Kolkata Knight Riders'],
    [11, 'Sunil Narine', 'All-rounder', 'West Indies', 50, 85, 'Kolkata Knight Riders', 'Kolkata Knight Riders'],
    [12, 'Shreyas Iyer', 'Batsman', 'India', 70, 15, 'Kolkata Knight Riders', 'Delhi Capitals'], # Transfer!
    [13, 'Rishabh Pant', 'Wicketkeeper', 'India', 80, 0, 'Delhi Capitals', 'Delhi Capitals'],
    [14, 'Axar Patel', 'All-rounder', 'India', 50, 70, 'Delhi Capitals', 'Delhi Capitals'],
    [15, 'Kuldeep Yadav', 'Bowler', 'India', 10, 85, 'Delhi Capitals', 'Delhi Capitals'],
    [16, 'KL Rahul', 'Batsman', 'India', 85, 0, 'Lucknow Super Giants', 'Lucknow Super Giants'],
    [17, 'Nicholas Pooran', 'Wicketkeeper', 'West Indies', 75, 0, 'Lucknow Super Giants', 'Lucknow Super Giants'],
    [18, 'Ravi Bishnoi', 'Bowler', 'India', 15, 80, 'Lucknow Super Giants', 'Lucknow Super Giants'],
    [19, 'Jos Buttler', 'Batsman', 'England', 85, 0, 'Rajasthan Royals', 'Rajasthan Royals'],
    [20, 'Sanju Samson', 'Wicketkeeper', 'India', 75, 0, 'Rajasthan Royals', 'Rajasthan Royals'],
    [21, 'Yuzvendra Chahal', 'Bowler', 'India', 5, 85, 'Rajasthan Royals', 'Rajasthan Royals'],
    [22, 'Shikhar Dhawan', 'Batsman', 'India', 70, 10, 'Punjab Kings', 'Punjab Kings'],
    [23, 'Liam Livingstone', 'All-rounder', 'England', 70, 50, 'Punjab Kings', 'Punjab Kings'],
    [24, 'Arshdeep Singh', 'Bowler', 'India', 5, 80, 'Punjab Kings', 'Punjab Kings'],
    [25, 'Rashid Khan', 'Bowler', 'Afghanistan', 30, 90, 'Gujarat Titans', 'Gujarat Titans'],
    [26, 'Shubman Gill', 'Batsman', 'India', 80, 0, 'Gujarat Titans', 'Gujarat Titans'],
    [27, 'Mohammed Shami', 'Bowler', 'India', 5, 85, 'Gujarat Titans', 'Gujarat Titans'],
    [28, 'Heinrich Klaasen', 'Wicketkeeper', 'South Africa', 75, 0, 'Sunrisers Hyderabad', 'Sunrisers Hyderabad'],
    [29, 'Abhishek Sharma', 'All-rounder', 'India', 65, 40, 'Sunrisers Hyderabad', 'Sunrisers Hyderabad'],
    [30, 'Pat Cummins', 'Bowler', 'Australia', 30, 85, 'Sunrisers Hyderabad', 'Kolkata Knight Riders']  # Transfer!
]

# Create players dataframe
players_df = pd.DataFrame(player_data, columns=['player_id', 'name', 'role', 'country',
                                              'batting_impact', 'bowling_impact',
                                              'team_2024', 'team_2025'])

# Calculate overall impact
players_df['overall_impact'] = players_df['batting_impact'] + players_df['bowling_impact']

# Create team affiliations for 2024 and 2025
affiliations_2024 = []
affiliations_2025 = []

for _, player in players_df.iterrows():
    # 2024 affiliation
    affiliations_2024.append({
        'player_id': player['player_id'],
        'name': player['name'],
        'team': player['team_2024'],
        'season': '2024',
        'batting_impact': player['batting_impact'],
        'bowling_impact': player['bowling_impact'],
        'overall_impact': player['overall_impact']
    })

    # 2025 affiliation
    affiliations_2025.append({
        'player_id': player['player_id'],
        'name': player['name'],
        'team': player['team_2025'],
        'season': '2025',
        'batting_impact': player['batting_impact'],
        'bowling_impact': player['bowling_impact'],
        'overall_impact': player['overall_impact']
    })

# Create DataFrames
affiliations_df = pd.DataFrame(affiliations_2024 + affiliations_2025)

# Save to CSV
players_df.to_csv("/content/drive/MyDrive/IPL_Prediction_Model/data/players_manual.csv", index=False)
affiliations_df.to_csv("/content/drive/MyDrive/IPL_Prediction_Model/data/player_affiliations.csv", index=False)

print("Manual player data created!")
print(f"Total players: {len(players_df)}")
print(f"2024 affiliations: {len(affiliations_2024)}")
print(f"2025 affiliations: {len(affiliations_2025)}")
print(f"Key transfers: Shreyas Iyer (KKR → DC), Pat Cummins (SRH → KKR)")

def calculate_team_strength(team_name, season, affiliations_df):
    """Calculate team strength based on player roster"""
    # Get players for team in the specified season
    team_players = affiliations_df[(affiliations_df['team'] == team_name) &
                                  (affiliations_df['season'] == season)]

    if len(team_players) == 0:
        return {
            'batting_strength': 0,
            'bowling_strength': 0,
            'overall_strength': 0,
            'player_count': 0
        }

    # Calculate team strengths
    batting_strength = team_players['batting_impact'].sum() / len(team_players)
    bowling_strength = team_players['bowling_impact'].sum() / len(team_players)
    overall_strength = team_players['overall_impact'].sum() / len(team_players)

    # Check for roster changes from previous season
    if season == '2025':
        prev_season = '2024'
        # Get players from previous season
        prev_players = affiliations_df[(affiliations_df['team'] == team_name) &
                                     (affiliations_df['season'] == prev_season)]

        # Calculate percentage of roster changed
        if len(prev_players) > 0:
            prev_ids = set(prev_players['player_id'])
            current_ids = set(team_players['player_id'])

            # Players who left
            left_team = prev_ids - current_ids
            # Players who joined
            joined_team = current_ids - prev_ids

            roster_change = (len(left_team) + len(joined_team)) / len(prev_ids)
        else:
            roster_change = 1.0  # New team
    else:
        roster_change = 0.0

    return {
        'batting_strength': batting_strength,
        'bowling_strength': bowling_strength,
        'overall_strength': overall_strength,
        'player_count': len(team_players),
        'roster_change': roster_change if season == '2025' else 0.0
    }

def predict_match_with_players(model, team1, team2, venue, city, toss_winner, toss_decision, season='2025'):
    """Predict match outcome using player-based team strengths"""
    print(f"Predicting {team1} vs {team2} for {season} season")

    # Load player affiliations
    affiliations_df = pd.read_csv("/content/drive/MyDrive/IPL_Prediction_Model/data/player_affiliations.csv")

    # Calculate team strengths
    team1_strength = calculate_team_strength(team1, season, affiliations_df)
    team2_strength = calculate_team_strength(team2, season, affiliations_df)

    print(f"{team1} strength: {team1_strength['overall_strength']:.2f} (B: {team1_strength['batting_strength']:.2f}, Bo: {team1_strength['bowling_strength']:.2f})")
    print(f"{team2} strength: {team2_strength['overall_strength']:.2f} (B: {team2_strength['batting_strength']:.2f}, Bo: {team2_strength['bowling_strength']:.2f})")

    # Calculate win probability based on team strengths
    team1_advantage = team1_strength['overall_strength'] - team2_strength['overall_strength']
    base_win_prob = 0.5 + (team1_advantage / 200)  # Convert to probability

    # Apply toss advantage (3% boost)
    toss_advantage = 0.03 if toss_winner == team1 else -0.03

    # Apply venue advantage (5% boost for home team)
    venue_advantage = 0.0
    if 'Mumbai' in venue and team1 == 'Mumbai Indians':
        venue_advantage = 0.05
    elif 'Chennai' in venue and team1 == 'Chennai Super Kings':
        venue_advantage = 0.05
    elif 'Bangalore' in venue and team1 == 'Royal Challengers Bangalore':
        venue_advantage = 0.05
    # Add more venue checks as needed

    # Calculate final probability
    final_prob = base_win_prob + toss_advantage + venue_advantage
    final_prob = max(0.01, min(0.99, final_prob))  # Keep between 1% and 99%

    if final_prob > 0.5:
        return f"{team1} win with {final_prob*100:.2f}% probability"
    else:
        return f"{team2} win with {(1-final_prob)*100:.2f}% probability"

# Test prediction with teams that have key transfers
def predict_match_player_based(team1, team2, venue, city, toss_winner, toss_decision, affiliations_df, season='2025'):
    """Self-contained prediction function using player data"""
    print(f"Predicting {team1} vs {team2} for {season} season")

    # Calculate team strengths
    team1_players = affiliations_df[(affiliations_df['team'] == team1) & (affiliations_df['season'] == season)]
    team2_players = affiliations_df[(affiliations_df['team'] == team2) & (affiliations_df['season'] == season)]

    # Calculate average impact scores
    team1_batting = team1_players['batting_impact'].mean() if len(team1_players) > 0 else 0
    team1_bowling = team1_players['bowling_impact'].mean() if len(team1_players) > 0 else 0
    team1_overall = team1_players['overall_impact'].mean() if len(team1_players) > 0 else 0

    team2_batting = team2_players['batting_impact'].mean() if len(team2_players) > 0 else 0
    team2_bowling = team2_players['bowling_impact'].mean() if len(team2_players) > 0 else 0
    team2_overall = team2_players['overall_impact'].mean() if len(team2_players) > 0 else 0

    print(f"{team1} strength: {team1_overall:.2f} (B: {team1_batting:.2f}, Bo: {team1_bowling:.2f})")
    print(f"{team2} strength: {team2_overall:.2f} (B: {team2_batting:.2f}, Bo: {team2_bowling:.2f})")

    # Calculate win probability
    team1_advantage = team1_overall - team2_overall
    base_win_prob = 0.5 + (team1_advantage / 200)

    # Apply toss advantage (3%)
    toss_advantage = 0.03 if toss_winner == team1 else -0.03

    # Calculate final probability
    final_prob = base_win_prob + toss_advantage
    final_prob = max(0.01, min(0.99, final_prob))

    if final_prob > 0.5:
        return f"{team1} win with {final_prob*100:.2f}% probability"
    else:
        return f"{team2} win with {(1-final_prob)*100:.2f}% probability"

# Try a match prediction with our player data
result = predict_match_player_based(
    'Kolkata Knight Riders',
    'Delhi Capitals',
    'Eden Gardens',
    'Kolkata',
    'Kolkata Knight Riders',
    'bat',
    affiliations_df,
    '2025'
)
print("\nFinal prediction:", result)

# Compare 2024 vs 2025 prediction
print("--- 2024 SEASON PREDICTION ---")
result_2024 = predict_match_player_based(
    'Kolkata Knight Riders', 'Delhi Capitals',
    'Eden Gardens', 'Kolkata',
    'Kolkata Knight Riders', 'bat',
    affiliations_df, '2024'
)

print("\n--- 2025 SEASON PREDICTION ---")
result_2025 = predict_match_player_based(
    'Kolkata Knight Riders', 'Delhi Capitals',
    'Eden Gardens', 'Kolkata',
    'Kolkata Knight Riders', 'bat',
    affiliations_df, '2025'
)

# Predict tonight's match
tonight_result = predict_match_player_based(
    'Kolkata Knight Riders',
    'Royal Challengers Bangalore',
    'Eden Gardens',
    'Kolkata',
    'Kolakata Knight Riders',
    'Bat',
    affiliations_df,
    '2025'
)
print(tonight_result)

tonight_result = predict_match_player_based(
    'Kolkata Knight Riders',
    'Royal Challengers Bangalore',
    'Eden Gardens',
    'Kolkata',
    'Kolakata Knight Riders',
    'Bowl',
    affiliations_df,
    '2025'
)
print(tonight_result)

tonight_result = predict_match_player_based(
    'Kolkata Knight Riders',
    'Royal Challengers Bangalore',
    'Eden Gardens',
    'Kolkata',
    'Royal Challengers Bangalore',
    'Bat',
    affiliations_df,
    '2025'
)
print(tonight_result)

tonight_result = predict_match_player_based(
    'Kolkata Knight Riders',
    'Royal Challengers Bangalore',
    'Eden Gardens',
    'Kolkata',
    'Royal Challengers Bangalore',
    'Bowl',
    affiliations_df,
    '2025'
)
print(tonight_result)

# Predict SRH vs RR match
srh_rr_prediction = predict_match_player_based(
   'Sunrisers Hyderabad',
   'Rajasthan Royals',
   'Rajiv Gandhi International Stadium',
   'Hyderabad',
   'Sunrisers Hyderabad',  # Change for different toss scenarios
   'bat',  # Change for different toss scenarios
   affiliations_df,
   '2025'
)
print(srh_rr_prediction)

# Predict SRH vs RR match
srh_rr_prediction = predict_match_player_based(
   'Sunrisers Hyderabad',
   'Rajasthan Royals',
   'Rajiv Gandhi International Stadium',
   'Hyderabad',
   'Sunrisers Hyderabad',  # Change for different toss scenarios
   'bowl',  # Change for different toss scenarios
   affiliations_df,
   '2025'
)
print(srh_rr_prediction)

# Predict SRH vs RR match
srh_rr_prediction = predict_match_player_based(
   'Sunrisers Hyderabad',
   'Rajasthan Royals',
   'Rajiv Gandhi International Stadium',
   'Hyderabad',
   'Rajasthan Royals',  # Change for different toss scenarios
   'bat',  # Change for different toss scenarios
   affiliations_df,
   '2025'
)
print(srh_rr_prediction)

# Predict SRH vs RR match
srh_rr_prediction = predict_match_player_based(
   'Sunrisers Hyderabad',
   'Rajasthan Royals',
   'Rajiv Gandhi International Stadium',
   'Hyderabad',
   'Rajasthan Royals',  # Change for different toss scenarios
   'bowl',  # Change for different toss scenarios
   affiliations_df,
   '2025'
)
print(srh_rr_prediction)

import pandas as pd
import numpy as np
import os
import datetime

# Ensure directories exist
os.makedirs("/content/drive/MyDrive/IPL_Prediction_Model/data/match_data", exist_ok=True)
os.makedirs("/content/drive/MyDrive/IPL_Prediction_Model/results", exist_ok=True)

# Create or load match performance data
def load_or_create_match_data():
    """Load existing match data or create initial dataset"""
    match_data_path = "/content/drive/MyDrive/IPL_Prediction_Model/data/match_data/player_performances.csv"

    if os.path.exists(match_data_path):
        return pd.read_csv(match_data_path)

    # Create initial dataset with recent performances (last 5 matches)
    performances = []

    # Get player data
    player_teams_df = pd.read_csv("/content/drive/MyDrive/IPL_Prediction_Model/data/player_affiliations.csv")
    players_df = pd.read_csv("/content/drive/MyDrive/IPL_Prediction_Model/data/players_manual.csv")

    # Generate synthetic recent match data for 2025 season
    for _, player in players_df.iterrows():
        player_id = player['player_id']
        name = player['name']
        role = player['role']
        team = player['team_2025']

        base_batting = player['batting_impact']
        base_bowling = player['bowling_impact']

        # Generate 5 recent matches with realistic performance data
        for i in range(5):
            match_date = (datetime.datetime.now() - datetime.timedelta(days=(5-i)*3)).strftime('%Y-%m-%d')

            # Batting performance varies by ±30% from baseline
            batting_variance = np.random.uniform(0.7, 1.3)

            # Calculate batting stats based on role and base impact
            if role == 'Batsman' or role == 'All-rounder' or role == 'Wicketkeeper':
                runs_scored = int(base_batting * batting_variance / 2)
                balls_faced = max(1, int(runs_scored / (base_batting/100) * 1.2))
                batting_sr = (runs_scored / balls_faced) * 100 if balls_faced > 0 else 0
            else:
                runs_scored = int(base_batting * batting_variance / 4)
                balls_faced = max(1, int(runs_scored / (base_batting/100) * 1.5))
                batting_sr = (runs_scored / balls_faced) * 100 if balls_faced > 0 else 0

            # Bowling performance varies by ±30% from baseline
            bowling_variance = np.random.uniform(0.7, 1.3)

            # Calculate bowling stats based on role and base impact
            if role == 'Bowler' or role == 'All-rounder':
                overs_bowled = min(4, max(1, int(base_bowling / 20)))
                wickets = int((base_bowling * bowling_variance) / 25)
                runs_conceded = int((base_bowling / bowling_variance) * overs_bowled / 5)
                economy = runs_conceded / overs_bowled if overs_bowled > 0 else 0
            else:
                overs_bowled = 0
                wickets = 0
                runs_conceded = 0
                economy = 0

            # Match result (win/loss doesn't affect individual form calculation)
            match_result = np.random.choice(['win', 'loss'])

            # Create performance entry
            performances.append({
                'player_id': player_id,
                'name': name,
                'team': team,
                'role': role,
                'match_date': match_date,
                'match_id': f'IPL2025_PREV_{i+1}',
                'runs_scored': runs_scored,
                'balls_faced': balls_faced,
                'batting_sr': batting_sr,
                'overs_bowled': overs_bowled,
                'wickets': wickets,
                'runs_conceded': runs_conceded,
                'economy': economy,
                'match_result': match_result
            })

    # Create and save dataframe
    performance_df = pd.DataFrame(performances)
    performance_df.to_csv(match_data_path, index=False)
    return performance_df

# Load or create player performance data
player_performances = load_or_create_match_data()

# Calculate player form factors
def calculate_player_form(player_performances, player_id, recency_weight=0.7):
    """Calculate player form based on recent performances"""
    # Get player's recent matches
    player_matches = player_performances[player_performances['player_id'] == player_id].sort_values('match_date')

    if len(player_matches) == 0:
        return 0.0  # Neutral form if no data

    # Get role and calculate appropriate form metric
    role = player_matches.iloc[0]['role']

    # Calculate batting form
    batting_impact = 0
    if role in ['Batsman', 'All-rounder', 'Wicketkeeper']:
        # Weight recent performances more heavily
        weights = [(1-recency_weight) + recency_weight * i/len(player_matches) for i in range(len(player_matches))]

        # Calculate weighted batting stats
        weighted_sr = sum(player_matches['batting_sr'] * weights) / sum(weights) if sum(weights) > 0 else 0
        weighted_runs = sum(player_matches['runs_scored'] * weights) / sum(weights) if sum(weights) > 0 else 0

        # Convert to form factor (-0.3 to +0.3)
        if weighted_sr > 0:
            # Higher SR = better form
            batting_impact = (weighted_sr / 150 - 1) * 0.3
            # Adjust for consistency in run scoring
            runs_impact = (weighted_runs / 30 - 1) * 0.15
            batting_impact = (batting_impact + runs_impact) / 2

    # Calculate bowling form
    bowling_impact = 0
    if role in ['Bowler', 'All-rounder']:
        weights = [(1-recency_weight) + recency_weight * i/len(player_matches) for i in range(len(player_matches))]

        # Lower economy = better form
        weighted_economy = sum(player_matches['economy'] * weights) / sum(weights) if sum(weights) > 0 else 0
        # Higher wickets = better form
        weighted_wickets = sum(player_matches['wickets'] * weights) / sum(weights) if sum(weights) > 0 else 0

        if weighted_economy > 0:
            # Economy impact (lower is better)
            economy_impact = (1 - weighted_economy / 8) * 0.3
            # Wicket-taking impact
            wicket_impact = min(0.3, weighted_wickets / 2)
            bowling_impact = (economy_impact + wicket_impact) / 2

    # Overall form impact
    if role == 'Batsman' or role == 'Wicketkeeper':
        overall_impact = batting_impact
    elif role == 'Bowler':
        overall_impact = bowling_impact
    else:  # All-rounder
        overall_impact = (batting_impact + bowling_impact) / 2

    # Clamp between -0.3 and +0.3
    return max(-0.3, min(0.3, overall_impact))

# Update player data with form factors
def update_player_impacts_with_form(affiliations_df, player_performances):
    """Update player impact scores with form factors"""
    # Calculate form factors for each player
    form_factors = {}
    unique_players = affiliations_df['player_id'].unique()

    for player_id in unique_players:
        form_factors[player_id] = calculate_player_form(player_performances, player_id)

    # Apply form factors to player impacts
    affiliations_df['form_factor'] = affiliations_df['player_id'].map(form_factors)

    # Apply form adjustments to impact scores
    affiliations_df['batting_impact_adjusted'] = affiliations_df['batting_impact'] * (1 + affiliations_df['form_factor'])
    affiliations_df['bowling_impact_adjusted'] = affiliations_df['bowling_impact'] * (1 + affiliations_df['form_factor'])
    affiliations_df['overall_impact_adjusted'] = affiliations_df['batting_impact_adjusted'] + affiliations_df['bowling_impact_adjusted']

    return affiliations_df

# Load player affiliations
affiliations_df = pd.read_csv("/content/drive/MyDrive/IPL_Prediction_Model/data/player_affiliations.csv")

# Apply form tracking
affiliations_df = update_player_impacts_with_form(affiliations_df, player_performances)

# Save updated affiliations
affiliations_df.to_csv("/content/drive/MyDrive/IPL_Prediction_Model/data/player_affiliations_with_form.csv", index=False)

# Enhanced prediction function with form factors
def predict_match_with_form(team1, team2, venue, city, toss_winner, toss_decision, season='2025',
                           home_advantage=0.05, toss_advantage=0.03):
    """Production-ready prediction with form factors"""
    # Load data with form
    affiliation_path = "/content/drive/MyDrive/IPL_Prediction_Model/data/player_affiliations_with_form.csv"
    if os.path.exists(affiliation_path):
        affiliations_form_df = pd.read_csv(affiliation_path)
    else:
        affiliations_form_df = update_player_impacts_with_form(affiliations_df, player_performances)

    # Get team players with adjusted impacts
    team1_players = affiliations_form_df[(affiliations_form_df['team'] == team1) &
                                         (affiliations_form_df['season'] == season)]
    team2_players = affiliations_form_df[(affiliations_form_df['team'] == team2) &
                                         (affiliations_form_df['season'] == season)]

    # Calculate form-adjusted team strengths
    team1_batting = team1_players['batting_impact_adjusted'].mean() if len(team1_players) > 0 else 0
    team1_bowling = team1_players['bowling_impact_adjusted'].mean() if len(team1_players) > 0 else 0
    team1_overall = team1_players['overall_impact_adjusted'].mean() if len(team1_players) > 0 else 0

    team2_batting = team2_players['batting_impact_adjusted'].mean() if len(team2_players) > 0 else 0
    team2_bowling = team2_players['bowling_impact_adjusted'].mean() if len(team2_players) > 0 else 0
    team2_overall = team2_players['overall_impact_adjusted'].mean() if len(team2_players) > 0 else 0

    # Display team strengths
    print(f"\n--- {team1} vs {team2} at {venue} ---")
    print(f"{team1} form-adjusted strength: {team1_overall:.2f} (Batting: {team1_batting:.2f}, Bowling: {team1_bowling:.2f})")
    print(f"{team2} form-adjusted strength: {team2_overall:.2f} (Batting: {team2_batting:.2f}, Bowling: {team2_bowling:.2f})")

    # Calculate win probability
    team1_advantage = team1_overall - team2_overall
    base_win_prob = 0.5 + (team1_advantage / 200)

    # Apply toss advantage
    toss_factor = toss_advantage if toss_winner == team1 else -toss_advantage

    # Apply home advantage
    home_factor = 0.0
    if team1 in venue or team1.split()[0] in venue or team1.split()[-1] in venue:
        home_factor = home_advantage
    elif team2 in venue or team2.split()[0] in venue or team2.split()[-1] in venue:
        home_factor = -home_advantage

    # Calculate final probability
    final_prob = base_win_prob + toss_factor + home_factor
    final_prob = max(0.01, min(0.99, final_prob))

    # Display factors
    print(f"Base probability: {base_win_prob*100:.2f}%")
    print(f"Toss factor: {toss_factor*100:+.2f}%")
    print(f"Home advantage: {home_factor*100:+.2f}%")

    # Save prediction to log
    prediction_log = {
        'date': datetime.datetime.now().strftime('%Y-%m-%d'),
        'team1': team1,
        'team2': team2,
        'venue': venue,
        'city': city,
        'toss_winner': toss_winner,
        'toss_decision': toss_decision,
        'season': season,
        'team1_strength': team1_overall,
        'team2_strength': team2_overall,
        'base_probability': base_win_prob,
        'toss_factor': toss_factor,
        'home_factor': home_factor,
        'final_probability': final_prob
    }

    # Append to prediction log
    prediction_log_df = pd.DataFrame([prediction_log])
    log_path = "/content/drive/MyDrive/IPL_Prediction_Model/results/prediction_log.csv"

    if os.path.exists(log_path):
        existing_log = pd.read_csv(log_path)
        updated_log = pd.concat([existing_log, prediction_log_df])
    else:
        updated_log = prediction_log_df

    updated_log.to_csv(log_path, index=False)

    # Return formatted result
    if final_prob > 0.5:
        return f"{team1} win with {final_prob*100:.2f}% probability"
    else:
        return f"{team2} win with {(1-final_prob)*100:.2f}% probability"

# Predict tonight's match
prediction = predict_match_with_form(
    'Kolkata Knight Riders',
    'Royal Challengers Bangalore',
    'Eden Gardens',
    'Kolkata',
    'Kolkata Knight Riders',  # Change after toss
    'bat',                   # Change after toss
    '2025'
)

print(f"\nFinal prediction: {prediction}")

# Simplified version for tonight's match prediction
def predict_tonight_match(team1, team2, venue, city, toss_winner, toss_decision):
    """Quick prediction function for tonight's match"""
    # Get team player data
    player_data = pd.read_csv("/content/drive/MyDrive/IPL_Prediction_Model/data/players_manual.csv")

    # Calculate team strengths
    team1_players = player_data[player_data['team_2025'] == team1]
    team2_players = player_data[player_data['team_2025'] == team2]

    team1_batting = team1_players['batting_impact'].mean()
    team1_bowling = team1_players['bowling_impact'].mean()
    team1_overall = team1_batting + team1_bowling

    team2_batting = team2_players['batting_impact'].mean()
    team2_bowling = team2_players['bowling_impact'].mean()
    team2_overall = team2_batting + team2_bowling

    print(f"\n--- {team1} vs {team2} at {venue} ---")
    print(f"{team1} strength: {team1_overall:.2f} (Batting: {team1_batting:.2f}, Bowling: {team1_bowling:.2f})")
    print(f"{team2} strength: {team2_overall:.2f} (Batting: {team2_batting:.2f}, Bowling: {team2_bowling:.2f})")

    # Calculate win probability
    team1_advantage = team1_overall - team2_overall
    base_win_prob = 0.5 + (team1_advantage / 200)

    # Apply toss advantage (3%)
    toss_factor = 0.03 if toss_winner == team1 else -0.03

    # Apply home advantage (5%)
    home_factor = 0.05 if venue in [team1, team1.split()[0], team1.split()[-1]] else 0

    # Calculate final probability
    final_prob = base_win_prob + toss_factor + home_factor
    final_prob = max(0.01, min(0.99, final_prob))

    print(f"Base probability: {base_win_prob*100:.2f}%")
    print(f"Toss factor: {toss_factor*100:+.2f}%")
    print(f"Home advantage: {home_factor*100:+.2f}%")

    # Return formatted result
    if final_prob > 0.5:
        return f"{team1} win with {final_prob*100:.2f}% probability"
    else:
        return f"{team2} win with {(1-final_prob)*100:.2f}% probability"

# Predict tonight's match
prediction = predict_tonight_match(
    'Kolkata Knight Riders',
    'Royal Challengers Bangalore',
    'Eden Gardens',
    'Kolkata',
    'Kolkata Knight Riders',  # Change after toss
    'bat'                    # Change after toss
)

print(f"\nFinal prediction: {prediction}")

# Full match prediction including both toss scenarios
def predict_match_for_betting(team1, team2, venue, city):
    """Generate predictions for all toss scenarios"""
    player_data = pd.read_csv("/content/drive/MyDrive/IPL_Prediction_Model/data/players_manual.csv")

    # Calculate team strengths
    team1_players = player_data[player_data['team_2025'] == team1]
    team2_players = player_data[player_data['team_2025'] == team2]

    team1_batting = team1_players['batting_impact'].mean()
    team1_bowling = team1_players['bowling_impact'].mean()
    team1_overall = team1_batting + team1_bowling

    team2_batting = team2_players['batting_impact'].mean()
    team2_bowling = team2_players['bowling_impact'].mean()
    team2_overall = team2_batting + team2_bowling

    print(f"\n=== {team1} vs {team2} at {venue} ===")
    print(f"{team1} strength: {team1_overall:.2f} (Batting: {team1_batting:.2f}, Bowling: {team1_bowling:.2f})")
    print(f"{team2} strength: {team2_overall:.2f} (Batting: {team2_batting:.2f}, Bowling: {team2_bowling:.2f})")

    # Base probability from team strength
    team1_advantage = team1_overall - team2_overall
    base_win_prob = 0.5 + (team1_advantage / 200)

    # Home advantage (5%)
    home_factor = 0.05 if team1 in venue or team1.split()[-1] in venue else 0

    # Calculate probabilities for all toss scenarios
    scenarios = [
        (team1, 'bat'),
        (team1, 'field'),
        (team2, 'bat'),
        (team2, 'field')
    ]

    results = []
    for toss_winner, toss_decision in scenarios:
        # Apply toss advantage (3%)
        toss_factor = 0.03 if toss_winner == team1 else -0.03

        # Final probability
        final_prob = base_win_prob + toss_factor + home_factor
        final_prob = max(0.01, min(0.99, final_prob))

        if final_prob > 0.5:
            winner = team1
            win_prob = final_prob
        else:
            winner = team2
            win_prob = 1 - final_prob

        results.append({
            'toss_winner': toss_winner,
            'toss_decision': toss_decision,
            'predicted_winner': winner,
            'win_probability': win_prob * 100
        })

    return results

# Get predictions for both matches
kkr_rcb = predict_match_for_betting('Kolkata Knight Riders', 'Royal Challengers Bangalore', 'Eden Gardens', 'Kolkata')
srh_rr = predict_match_for_betting('Sunrisers Hyderabad', 'Rajasthan Royals', 'Rajiv Gandhi International Stadium', 'Hyderabad')

# Print recommendations
print("\n----- BETTING RECOMMENDATIONS -----")
print("Wait for the toss before placing bets")

for match_name, results in [("KKR vs RCB", kkr_rcb), ("SRH vs RR", srh_rr)]:
    avg_prob = sum(r['win_probability'] for r in results) / len(results)
    most_likely = max(results, key=lambda x: x['win_probability'])

    print(f"\n{match_name}:")
    print(f"Strongest prediction: {most_likely['predicted_winner']} ({most_likely['win_probability']:.1f}%)")
    print(f"Average win probability: {avg_prob:.1f}%")

    # Betting recommendation
    if avg_prob > 65:
        print(f"Recommendation: Strong bet on {most_likely['predicted_winner']}")
    elif avg_prob > 60:
        print(f"Recommendation: Moderate bet on {most_likely['predicted_winner']}")
    elif avg_prob > 55:
        print(f"Recommendation: Small bet on {most_likely['predicted_winner']}")
    else:
        print("Recommendation: Avoid betting (too close to call)")

# Add venue characteristics database
venue_data = {
    'Eden Gardens': {'batting_factor': 0.05, 'bowling_type': 'spin', 'avg_score': 175},
    'Wankhede Stadium': {'batting_factor': 0.1, 'bowling_type': 'pace', 'avg_score': 185},
    'M. A. Chidambaram Stadium': {'batting_factor': -0.05, 'bowling_type': 'spin', 'avg_score': 165},
    'Arun Jaitley Stadium': {'batting_factor': 0.15, 'bowling_type': 'balanced', 'avg_score': 190},
    'Narendra Modi Stadium': {'batting_factor': 0.0, 'bowling_type': 'balanced', 'avg_score': 175},
    'M Chinnaswamy Stadium': {'batting_factor': 0.2, 'bowling_type': 'pace', 'avg_score': 195},
    'Punjab Cricket Association Stadium': {'batting_factor': 0.05, 'bowling_type': 'pace', 'avg_score': 180},
    'Rajiv Gandhi International Stadium': {'batting_factor': 0.0, 'bowling_type': 'spin', 'avg_score': 170},
    'Sawai Mansingh Stadium': {'batting_factor': -0.02, 'bowling_type': 'balanced', 'avg_score': 173},
    'Barsapara Cricket Stadium': {'batting_factor': 0.03, 'bowling_type': 'pace', 'avg_score': 178}
}

def predict_with_venue_analysis(team1, team2, venue, city, toss_winner, toss_decision):
    """Enhanced prediction with venue analysis"""
    # Get team data
    player_data = pd.read_csv("/content/drive/MyDrive/IPL_Prediction_Model/data/players_manual.csv")

    # Get venue data
    venue_info = venue_data.get(venue, {'batting_factor': 0.0, 'bowling_type': 'balanced', 'avg_score': 175})

    # Calculate team strengths with venue adjustments
    team1_players = player_data[player_data['team_2025'] == team1]
    team2_players = player_data[player_data['team_2025'] == team2]

    # Apply venue-specific adjustments
    # Bowlers who match the venue type get a boost
    team1_bowling = team1_players['bowling_impact'].mean()
    team2_bowling = team2_players['bowling_impact'].mean()

    # Batsmen adjustment based on venue batting factor
    team1_batting = team1_players['batting_impact'].mean() * (1 + venue_info['batting_factor'])
    team2_batting = team2_players['batting_impact'].mean() * (1 + venue_info['batting_factor'])

    # Adjust bowling based on venue type
    team1_spin_bowlers = len(team1_players[team1_players['role'] == 'Bowler'])
    team2_spin_bowlers = len(team2_players[team2_players['role'] == 'Bowler'])

    if venue_info['bowling_type'] == 'spin':
        # Teams with more spin bowlers get advantage
        team1_bowling *= (1 + 0.05 * team1_spin_bowlers / max(1, len(team1_players)))
        team2_bowling *= (1 + 0.05 * team2_spin_bowlers / max(1, len(team2_players)))

    team1_overall = team1_batting + team1_bowling
    team2_overall = team2_batting + team2_bowling

    print(f"\n=== {team1} vs {team2} at {venue} ===")
    print(f"Venue characteristics: {venue_info['bowling_type']} bowling, batting factor {venue_info['batting_factor']}")
    print(f"{team1} adjusted strength: {team1_overall:.2f} (Batting: {team1_batting:.2f}, Bowling: {team1_bowling:.2f})")
    print(f"{team2} adjusted strength: {team2_overall:.2f} (Batting: {team2_batting:.2f}, Bowling: {team2_bowling:.2f})")

    # Base probability from team strength
    team1_advantage = team1_overall - team2_overall
    base_win_prob = 0.5 + (team1_advantage / 200)

    # Home advantage (5%)
    home_factor = 0.05 if team1 in venue or team1.split()[-1] in venue else 0

    # Toss factor
    toss_factor = 0.03 if toss_winner == team1 else -0.03

    # Chasing advantage (if applicable)
    chase_advantage = 0.02 if venue_info['batting_factor'] > 0.1 and toss_decision == 'field' else 0
    chase_advantage *= 1 if toss_winner == team1 else -1

    # Final probability
    final_prob = base_win_prob + toss_factor + home_factor + chase_advantage
    final_prob = max(0.01, min(0.99, final_prob))

    print(f"Base probability: {base_win_prob*100:.2f}%")
    print(f"Toss factor: {toss_factor*100:+.2f}%")
    print(f"Home advantage: {home_factor*100:+.2f}%")
    print(f"Chase advantage: {chase_advantage*100:+.2f}%")

    if final_prob > 0.5:
        return f"{team1} win with {final_prob*100:.2f}% probability"
    else:
        return f"{team2} win with {(1-final_prob)*100:.2f}% probability"

# Test on tonight's matches
kkr_rcb = predict_with_venue_analysis(
    'Kolkata Knight Riders',
    'Royal Challengers Bangalore',
    'Eden Gardens',
    'Kolkata',
    'Kolkata Knight Riders',
    'bat'
)

srh_rr = predict_with_venue_analysis(
    'Sunrisers Hyderabad',
    'Rajasthan Royals',
    'Rajiv Gandhi International Stadium',
    'Hyderabad',
    'Sunrisers Hyderabad',
    'bat'
)

# Complete player matchup database
player_matchups = {
    # Batsmen vs bowling type factors
    1: {'vs_spin': 0.95, 'vs_pace': 1.10},  # Rohit Sharma
    2: {'vs_spin': 1.10, 'vs_pace': 0.95},  # Hardik Pandya
    3: {'vs_spin': 0.90, 'vs_pace': 1.10},  # Jasprit Bumrah
    4: {'vs_spin': 1.15, 'vs_pace': 0.90},  # MS Dhoni
    5: {'vs_spin': 1.20, 'vs_pace': 0.90},  # Ravindra Jadeja
    6: {'vs_spin': 1.05, 'vs_pace': 1.00},  # Ruturaj Gaikwad
    7: {'vs_spin': 1.15, 'vs_pace': 0.95},  # Virat Kohli
    8: {'vs_spin': 1.00, 'vs_pace': 1.10},  # Glenn Maxwell
    9: {'vs_spin': 0.90, 'vs_pace': 1.15},  # Mohammed Siraj
    10: {'vs_spin': 0.95, 'vs_pace': 1.10}, # Andre Russell
    11: {'vs_spin': 1.20, 'vs_pace': 0.85}, # Sunil Narine
    12: {'vs_spin': 1.10, 'vs_pace': 0.95}, # Shreyas Iyer
    13: {'vs_spin': 1.05, 'vs_pace': 1.05}, # Rishabh Pant
    14: {'vs_spin': 1.20, 'vs_pace': 0.90}, # Axar Patel
    15: {'vs_spin': 1.25, 'vs_pace': 0.85}, # Kuldeep Yadav
    16: {'vs_spin': 1.05, 'vs_pace': 1.05}, # KL Rahul
    17: {'vs_spin': 1.10, 'vs_pace': 1.00}, # Nicholas Pooran
    18: {'vs_spin': 1.20, 'vs_pace': 0.90}, # Ravi Bishnoi
    19: {'vs_spin': 1.00, 'vs_pace': 1.10}, # Jos Buttler
    20: {'vs_spin': 1.05, 'vs_pace': 1.05}, # Sanju Samson
    21: {'vs_spin': 1.25, 'vs_pace': 0.85}, # Yuzvendra Chahal
    22: {'vs_spin': 1.10, 'vs_pace': 0.95}, # Shikhar Dhawan
    23: {'vs_spin': 1.00, 'vs_pace': 1.10}, # Liam Livingstone
    24: {'vs_spin': 0.90, 'vs_pace': 1.15}, # Arshdeep Singh
    25: {'vs_spin': 1.25, 'vs_pace': 0.85}, # Rashid Khan
    26: {'vs_spin': 1.05, 'vs_pace': 1.05}, # Shubman Gill
    27: {'vs_spin': 0.90, 'vs_pace': 1.15}, # Mohammed Shami
    28: {'vs_spin': 1.00, 'vs_pace': 1.10}, # Heinrich Klaasen
    29: {'vs_spin': 1.05, 'vs_pace': 1.00}, # Abhishek Sharma
    30: {'vs_spin': 0.90, 'vs_pace': 1.15}  # Pat Cummins
}

def predict_with_matchups(team1, team2, venue, city, toss_winner, toss_decision):
    """Enhanced prediction with player matchups"""
    # Load data
    player_data = pd.read_csv("/content/drive/MyDrive/IPL_Prediction_Model/data/players_manual.csv")
    venue_info = venue_data.get(venue, {'batting_factor': 0.0, 'bowling_type': 'balanced', 'avg_score': 175})

    # Get team players
    team1_players = player_data[player_data['team_2025'] == team1]
    team2_players = player_data[player_data['team_2025'] == team2]

    # Apply matchup-based adjustments
    bowling_type = venue_info['bowling_type']
    matchup_factor = 'vs_spin' if bowling_type == 'spin' else 'vs_pace'

    # Adjust batting impacts based on player matchups
    team1_batting_adjusted = 0
    for _, player in team1_players.iterrows():
        player_id = player['player_id']
        batting_impact = player['batting_impact']
        if player_id in player_matchups:
            adjustment = player_matchups[player_id].get(matchup_factor, 1.0)
            team1_batting_adjusted += batting_impact * adjustment
        else:
            team1_batting_adjusted += batting_impact
    team1_batting_adjusted /= max(1, len(team1_players))

    team2_batting_adjusted = 0
    for _, player in team2_players.iterrows():
        player_id = player['player_id']
        batting_impact = player['batting_impact']
        if player_id in player_matchups:
            adjustment = player_matchups[player_id].get(matchup_factor, 1.0)
            team2_batting_adjusted += batting_impact * adjustment
        else:
            team2_batting_adjusted += batting_impact
    team2_batting_adjusted /= max(1, len(team2_players))

    # Apply venue batting factor
    team1_batting_adjusted *= (1 + venue_info['batting_factor'])
    team2_batting_adjusted *= (1 + venue_info['batting_factor'])

    # Get bowling impacts
    team1_bowling = team1_players['bowling_impact'].mean()
    team2_bowling = team2_players['bowling_impact'].mean()

    # Calculate overall strength
    team1_overall = team1_batting_adjusted + team1_bowling
    team2_overall = team2_batting_adjusted + team2_bowling

    print(f"\n=== {team1} vs {team2} at {venue} ({bowling_type} pitch) ===")
    print(f"{team1} matchup-adjusted: {team1_overall:.2f} (Batting: {team1_batting_adjusted:.2f}, Bowling: {team1_bowling:.2f})")
    print(f"{team2} matchup-adjusted: {team2_overall:.2f} (Batting: {team2_batting_adjusted:.2f}, Bowling: {team2_bowling:.2f})")

    # Calculate win probability
    team1_advantage = team1_overall - team2_overall
    base_win_prob = 0.5 + (team1_advantage / 200)

    # Apply typical adjustments
    toss_factor = 0.03 if toss_winner == team1 else -0.03
    home_factor = 0.05 if team1 in venue or team1.split()[-1] in venue else 0

    # Final probability
    final_prob = base_win_prob + toss_factor + home_factor
    final_prob = max(0.01, min(0.99, final_prob))

    print(f"Base probability: {base_win_prob*100:.2f}%")
    print(f"Toss factor: {toss_factor*100:+.2f}%")
    print(f"Home advantage: {home_factor*100:+.2f}%")

    if final_prob > 0.5:
        return f"{team1} win with {final_prob*100:.2f}% probability"
    else:
        return f"{team2} win with {(1-final_prob)*100:.2f}% probability"

# Test on tonight's matches
kkr_rcb = predict_with_matchups(
    'Kolkata Knight Riders',
    'Royal Challengers Bangalore',
    'Eden Gardens',
    'Kolkata',
    'Kolkata Knight Riders',
    'bat'
)

srh_rr = predict_with_matchups(
    'Sunrisers Hyderabad',
    'Rajasthan Royals',
    'Rajiv Gandhi International Stadium',
    'Hyderabad',
    'Sunrisers Hyderabad',
    'bat'
)

print("\nFinal predictions:")
print(kkr_rcb)
print(srh_rr)

# Weather conditions database
weather_conditions = {
    'clear': {'toss_value': 0.03, 'field_advantage': 0.0},
    'overcast': {'toss_value': 0.04, 'field_advantage': 0.02},
    'humid': {'toss_value': 0.05, 'field_advantage': 0.03},
    'dew_expected': {'toss_value': 0.08, 'field_advantage': 0.06},
    'rain_threat': {'toss_value': 0.07, 'field_advantage': 0.05, 'dls_factor': 0.04}
}

def predict_with_weather(team1, team2, venue, city, toss_winner, toss_decision, weather='clear'):
    """Enhanced prediction with weather conditions"""
    # Load data
    player_data = pd.read_csv("/content/drive/MyDrive/IPL_Prediction_Model/data/players_manual.csv")
    venue_info = venue_data.get(venue, {'batting_factor': 0.0, 'bowling_type': 'balanced', 'avg_score': 175})
    weather_info = weather_conditions.get(weather, weather_conditions['clear'])

    # Get team strengths
    team1_players = player_data[player_data['team_2025'] == team1]
    team2_players = player_data[player_data['team_2025'] == team2]

    bowling_type = venue_info['bowling_type']
    matchup_factor = 'vs_spin' if bowling_type == 'spin' else 'vs_pace'

    # Calculate adjusted stats with matchups
    team1_batting_adjusted = 0
    team2_batting_adjusted = 0

    for _, player in team1_players.iterrows():
        player_id = player['player_id']
        batting_impact = player['batting_impact']
        adjustment = player_matchups.get(player_id, {}).get(matchup_factor, 1.0)
        team1_batting_adjusted += batting_impact * adjustment

    for _, player in team2_players.iterrows():
        player_id = player['player_id']
        batting_impact = player['batting_impact']
        adjustment = player_matchups.get(player_id, {}).get(matchup_factor, 1.0)
        team2_batting_adjusted += batting_impact * adjustment

    team1_batting_adjusted /= max(1, len(team1_players))
    team2_batting_adjusted /= max(1, len(team2_players))

    # Adjust for venue
    team1_batting_adjusted *= (1 + venue_info['batting_factor'])
    team2_batting_adjusted *= (1 + venue_info['batting_factor'])

    # Get bowling impacts
    team1_bowling = team1_players['bowling_impact'].mean()
    team2_bowling = team2_players['bowling_impact'].mean()

    # Calculate overall strength
    team1_overall = team1_batting_adjusted + team1_bowling
    team2_overall = team2_batting_adjusted + team2_bowling

    print(f"\n=== {team1} vs {team2} at {venue} | Weather: {weather} ===")
    print(f"{team1} adjusted: {team1_overall:.2f} (Batting: {team1_batting_adjusted:.2f}, Bowling: {team1_bowling:.2f})")
    print(f"{team2} adjusted: {team2_overall:.2f} (Batting: {team2_batting_adjusted:.2f}, Bowling: {team2_bowling:.2f})")

    # Calculate base probability
    team1_advantage = team1_overall - team2_overall
    base_win_prob = 0.5 + (team1_advantage / 200)

    # Toss advantage (varies by weather)
    toss_value = weather_info['toss_value']
    toss_factor = toss_value if toss_winner == team1 else -toss_value

    # Home advantage
    home_factor = 0.05 if team1 in venue or team1.split()[-1] in venue else 0

    # Field advantage in certain weather conditions
    field_advantage = 0
    if toss_decision == 'field':
        field_advantage = weather_info.get('field_advantage', 0)
        field_advantage *= 1 if toss_winner == team1 else -1

    # DLS advantage (if applicable)
    dls_factor = 0
    if 'dls_factor' in weather_info and weather in ['rain_threat']:
        # Teams with higher batting average do better in DLS
        batting_diff = team1_batting_adjusted - team2_batting_adjusted
        dls_factor = (batting_diff / 100) * weather_info['dls_factor']

    # Final probability
    final_prob = base_win_prob + toss_factor + home_factor + field_advantage + dls_factor
    final_prob = max(0.01, min(0.99, final_prob))

    print(f"Base probability: {base_win_prob*100:.2f}%")
    print(f"Toss factor: {toss_factor*100:+.2f}%")
    print(f"Home advantage: {home_factor*100:+.2f}%")
    print(f"Field advantage: {field_advantage*100:+.2f}%")
    if dls_factor != 0:
        print(f"DLS factor: {dls_factor*100:+.2f}%")

    if final_prob > 0.5:
        return f"{team1} win with {final_prob*100:.2f}% probability"
    else:
        return f"{team2} win with {(1-final_prob)*100:.2f}% probability"

# Test with different weather conditions
print("\n--- CLEAR WEATHER ---")
kkr_rcb_clear = predict_with_weather(
    'Kolkata Knight Riders',
    'Royal Challengers Bangalore',
    'Eden Gardens',
    'Kolkata',
    'Kolkata Knight Riders',
    'bat',
    'clear'
)

print("\n--- DEW EXPECTED ---")
kkr_rcb_dew = predict_with_weather(
    'Kolkata Knight Riders',
    'Royal Challengers Bangalore',
    'Eden Gardens',
    'Kolkata',
    'Kolkata Knight Riders',
    'field',
    'dew_expected'
)

print("\n--- TONIGHT'S FORECAST ---")
# Check weather for tonight's matches and run appropriate predictions

# Tonight's actual weather for KKR vs RCB
kkr_rcb_tonight = predict_with_weather(
    'Kolkata Knight Riders',
    'Royal Challengers Bangalore',
    'Eden Gardens',
    'Kolkata',
    'Kolkata Knight Riders',  # Change after toss
    'field',  # Change after toss
    'humid'  # Kolkata is humid tonight
)

# Tonight's weather for SRH vs RR
srh_rr_tonight = predict_with_weather(
    'Sunrisers Hyderabad',
    'Rajasthan Royals',
    'Rajiv Gandhi International Stadium',
    'Hyderabad',
    'Sunrisers Hyderabad',  # Change after toss
    'field',  # Change after toss
    'clear'  # Clear conditions in Hyderabad
)

print("\nFINAL BETTING RECOMMENDATIONS:")
print("1. " + kkr_rcb_tonight)
print("2. " + srh_rr_tonight)

# ML-based prediction enhancement
from sklearn.ensemble import RandomForestClassifier
import numpy as np

# Create synthetic training data from our model predictions
def generate_training_data(num_samples=200):
    """Generate synthetic training data for ML model"""
    team_names = ['Mumbai Indians', 'Chennai Super Kings', 'Royal Challengers Bangalore',
                 'Kolkata Knight Riders', 'Delhi Capitals', 'Punjab Kings',
                 'Rajasthan Royals', 'Sunrisers Hyderabad', 'Gujarat Titans', 'Lucknow Super Giants']

    X = []
    y = []

    for _ in range(num_samples):
        # Select random teams
        team1, team2 = np.random.choice(team_names, 2, replace=False)

        # Get team stats
        team1_batting = np.random.uniform(40, 80)
        team1_bowling = np.random.uniform(40, 80)
        team2_batting = np.random.uniform(40, 80)
        team2_bowling = np.random.uniform(40, 80)

        # Calculate strengths
        team1_overall = team1_batting + team1_bowling
        team2_overall = team2_batting + team2_bowling

        # Factors
        toss_winner = np.random.choice([0, 1])  # 0=team1, 1=team2
        home_advantage = np.random.choice([0, 1, 2])  # 0=neutral, 1=team1, 2=team2
        weather = np.random.choice([0, 1, 2, 3])  # 0=clear, 1=humid, 2=dew, 3=rain

        # Create feature vector
        features = [
            team1_batting, team1_bowling, team2_batting, team2_bowling,
            team1_overall, team2_overall, team1_overall - team2_overall,
            toss_winner, home_advantage, weather
        ]
        X.append(features)

        # Generate outcome with some randomness to simulate real matches
        base_prob = 0.5 + (team1_overall - team2_overall) / 200
        toss_factor = 0.05 if toss_winner == 0 else -0.05
        home_factor = 0.05 if home_advantage == 1 else (-0.05 if home_advantage == 2 else 0)

        final_prob = base_prob + toss_factor + home_factor

        # Add some randomness (upsets happen)
        random_factor = np.random.normal(0, 0.1)
        final_prob += random_factor

        # Determine winner
        team1_wins = np.random.random() < final_prob
        y.append(1 if team1_wins else 0)

    return np.array(X), np.array(y)

# Train ML model
def train_ml_model():
    """Train ML model on synthetic data"""
    X, y = generate_training_data(500)

    # Create and train model
    model = RandomForestClassifier(n_estimators=100, random_state=42)
    model.fit(X, y)

    return model

# Function to make ML-enhanced predictions
def predict_with_ml(team1, team2, venue, toss_winner, toss_decision, weather_condition):
    """Make prediction using ML model"""
    # Load player data
    player_data = pd.read_csv("/content/drive/MyDrive/IPL_Prediction_Model/data/players_manual.csv")

    # Get team strengths with adjusted impacts from previous functions
    team1_players = player_data[player_data['team_2025'] == team1]
    team2_players = player_data[player_data['team_2025'] == team2]

    team1_batting = team1_players['batting_impact'].mean()
    team1_bowling = team1_players['bowling_impact'].mean()
    team2_batting = team2_players['batting_impact'].mean()
    team2_bowling = team2_players['bowling_impact'].mean()

    team1_overall = team1_batting + team1_bowling
    team2_overall = team2_batting + team2_bowling

    # Convert categorical variables to numeric
    toss_winner_num = 0 if toss_winner == team1 else 1

    # Home advantage
    if team1 in venue or team1.split()[-1] in venue:
        home_advantage = 1  # team1 home
    elif team2 in venue or team2.split()[-1] in venue:
        home_advantage = 2  # team2 home
    else:
        home_advantage = 0  # neutral

    # Weather mapping
    weather_map = {'clear': 0, 'humid': 1, 'dew_expected': 2, 'rain_threat': 3}
    weather_num = weather_map.get(weather_condition, 0)

    # Create feature vector
    features = [
        team1_batting, team1_bowling, team2_batting, team2_bowling,
        team1_overall, team2_overall, team1_overall - team2_overall,
        toss_winner_num, home_advantage, weather_num
    ]

    # Train model
    ml_model = train_ml_model()

    # Get ML prediction (probability)
    proba = ml_model.predict_proba([features])[0]
    team1_win_prob = proba[1]

    # Get our rule-based prediction
    rule_based_prob = 0.5 + (team1_overall - team2_overall) / 200

    # Weather and toss adjustments
    weather_info = weather_conditions.get(weather_condition, weather_conditions['clear'])
    toss_value = weather_info['toss_value']
    field_advantage = weather_info.get('field_advantage', 0) if toss_decision == 'field' else 0

    toss_factor = toss_value if toss_winner == team1 else -toss_value
    field_factor = field_advantage if (toss_winner == team1 and toss_decision == 'field') else \
                   (-field_advantage if (toss_winner == team2 and toss_decision == 'field') else 0)
    home_factor = 0.05 if home_advantage == 1 else (-0.05 if home_advantage == 2 else 0)

    rule_based_prob += toss_factor + field_factor + home_factor

    # Ensemble prediction (combine ML and rule-based)
    ensemble_prob = 0.7 * ml_model.predict_proba([features])[0][1] + 0.3 * rule_based_prob

    print(f"\n=== ML-Enhanced Prediction: {team1} vs {team2} ===")
    print(f"{team1} stats: Batting={team1_batting:.2f}, Bowling={team1_bowling:.2f}")
    print(f"{team2} stats: Batting={team2_batting:.2f}, Bowling={team2_bowling:.2f}")
    print(f"Rule-based probability: {rule_based_prob*100:.2f}%")
    print(f"ML probability: {team1_win_prob*100:.2f}%")
    print(f"Ensemble probability: {ensemble_prob*100:.2f}%")

    if ensemble_prob > 0.5:
        return f"{team1} win with {ensemble_prob*100:.2f}% probability"
    else:
        return f"{team2} win with {(1-ensemble_prob)*100:.2f}% probability"

# Make ML-enhanced predictions
ml_kkr_rcb = predict_with_ml(
    'Kolkata Knight Riders',
    'Royal Challengers Bangalore',
    'Eden Gardens',
    'Kolkata Knight Riders',  # Change after toss
    'field',                 # Change after toss
    'humid'
)

ml_srh_rr = predict_with_ml(
    'Sunrisers Hyderabad',
    'Rajasthan Royals',
    'Rajiv Gandhi International Stadium',
    'Sunrisers Hyderabad',  # Change after toss
    'field',                # Change after toss
    'clear'
)

print("\nFINAL ML-ENHANCED PREDICTIONS:")
print("1. " + ml_kkr_rcb)
print("2. " + ml_srh_rr)

final_prediction = predict_with_ml(
    'Kolkata Knight Riders',
    'Sunrisers Hyderabad',
    'M. A. Chidambaram Stadium',  # Final venue in Chennai
    'Kolkata Knight Riders',      # KKR won the toss
    'bat',                        # KKR chose to bat
    'clear'                       # Weather was clear
)

final_prediction = predict_with_ml(
    'Rajasthan Royals',
    'Sunrisers Hyderabad',
    'M. A. Chidambaram Stadium',
    'Rjasthan Royals',
    'field',
    'clear'
)

print("\nFINAL ML-ENHANCED PREDICTIONS:")
print("1. " + final_prediction)

# Eliminator: RCB vs LSG
rcb_lsg = predict_with_ml(
    'Royal Challengers Bangalore',
    'Lucknow Super Giants',
    'Narendra Modi Stadium',
    'Royal Challengers Bangalore',
    'bat',
    'clear'
)

# Qualifier 1: KKR vs SRH
kkr_srh = predict_with_ml(
    'Kolkata Knight Riders',
    'Sunrisers Hyderabad',
    'Ahmedabad',
    'Kolkata Knight Riders',
    'bat',
    'clear'
)

# Final: KKR vs RR/SRH
final_match = predict_with_ml(
    'Kolkata Knight Riders',
    'Rajasthan Royals',  # Replace with winner of Qualifier 2
    'M. A. Chidambaram Stadium',
    'Kolkata Knight Riders',
    'bat',
    'clear'
)

def predict_match_with_clear_winner(team1, team2, venue, toss_winner, toss_decision, weather):
    """Prediction function that clearly states winner and betting advice"""
    # Load player data
    player_data = pd.read_csv("/content/drive/MyDrive/IPL_Prediction_Model/data/players_manual.csv")

    # Get team stats
    team1_players = player_data[player_data['team_2025'] == team1]
    team2_players = player_data[player_data['team_2025'] == team2]

    team1_batting = team1_players['batting_impact'].mean()
    team1_bowling = team1_players['bowling_impact'].mean()
    team1_overall = team1_batting + team1_bowling

    team2_batting = team2_players['batting_impact'].mean()
    team2_bowling = team2_players['bowling_impact'].mean()
    team2_overall = team2_batting + team2_bowling

    # Calculate probability
    team1_advantage = team1_overall - team2_overall
    base_prob = 0.5 + (team1_advantage / 200)

    # Apply adjustments
    weather_info = weather_conditions.get(weather, weather_conditions['clear'])
    toss_value = weather_info['toss_value']
    toss_factor = toss_value if toss_winner == team1 else -toss_value

    final_prob = base_prob + toss_factor

    # Generate ML probability
    ml_prob = 0.6 if final_prob > 0.5 else 0.4  # Simplified ML result

    # Ensemble probability
    ensemble_prob = 0.7 * ml_prob + 0.3 * final_prob

    # Determine winner and confidence
    if ensemble_prob > 0.5:
        winner = team1
        win_prob = ensemble_prob * 100
    else:
        winner = team2
        win_prob = (1 - ensemble_prob) * 100

    # Betting recommendation
    if win_prob > 65:
        bet_recommendation = f"Strong bet on {winner}"
    elif win_prob > 58:
        bet_recommendation = f"Moderate bet on {winner}"
    elif win_prob > 53:
        bet_recommendation = f"Small bet on {winner}"
    else:
        bet_recommendation = "Avoid betting (too close to call)"

    print(f"\n{team1} vs {team2} at {venue}")
    print(f"PREDICTED WINNER: {winner} ({win_prob:.1f}%)")
    print(f"BETTING ADVICE: {bet_recommendation}")

    return winner, win_prob, bet_recommendation

# Example for IPL 2024 Final
winner, win_prob, bet_advice = predict_match_with_clear_winner(
    'Kolkata Knight Riders',
    'Sunrisers Hyderabad',
    'M. A. Chidambaram Stadium',
    'Kolkata Knight Riders',
    'bat',
    'clear'
)

# Print results for all playoff matches
matches = [
    ('Royal Challengers Bangalore', 'Lucknow Super Giants', 'Narendra Modi Stadium'),
    ('Kolkata Knight Riders', 'Sunrisers Hyderabad', 'Ahmedabad'),
    ('Rajasthan Royals', 'Sunrisers Hyderabad', 'M. A. Chidambaram Stadium'),
    ('Kolkata Knight Riders', 'Rajasthan Royals', 'M. A. Chidambaram Stadium')
]

print("\nIPL 2024 PLAYOFF PREDICTIONS:")
for i, (team1, team2, venue) in enumerate(matches):
    winner, win_prob, bet_advice = predict_match_with_clear_winner(
        team1, team2, venue, team1, 'bat', 'clear'
    )

# Step 1: Save this function in your notebook
def predict_match_with_clear_winner(team1, team2, venue, toss_winner, toss_decision, weather='clear'):
    """Prediction function that clearly states winner and betting advice"""
    # Load player data
    player_data = pd.read_csv("/content/drive/MyDrive/IPL_Prediction_Model/data/players_manual.csv")

    # Get team stats
    team1_players = player_data[player_data['team_2025'] == team1]
    team2_players = player_data[player_data['team_2025'] == team2]

    team1_batting = team1_players['batting_impact'].mean()
    team1_bowling = team1_players['bowling_impact'].mean()
    team1_overall = team1_batting + team1_bowling

    team2_batting = team2_players['batting_impact'].mean()
    team2_bowling = team2_players['bowling_impact'].mean()
    team2_overall = team2_batting + team2_bowling

    # Calculate probability
    team1_advantage = team1_overall - team2_overall
    base_prob = 0.5 + (team1_advantage / 200)

    # Apply adjustments
    toss_value = 0.05
    toss_factor = toss_value if toss_winner == team1 else -toss_value

    final_prob = base_prob + toss_factor

    # Generate ML probability (simplified)
    ml_prob = 0.6 if final_prob > 0.5 else 0.4

    # Ensemble probability
    ensemble_prob = 0.7 * ml_prob + 0.3 * final_prob

    # Determine winner and confidence
    if ensemble_prob > 0.5:
        winner = team1
        win_prob = ensemble_prob * 100
    else:
        winner = team2
        win_prob = (1 - ensemble_prob) * 100

    # Betting recommendation
    if win_prob > 65:
        bet_recommendation = f"Strong bet on {winner}"
    elif win_prob > 58:
        bet_recommendation = f"Moderate bet on {winner}"
    elif win_prob > 53:
        bet_recommendation = f"Small bet on {winner}"
    else:
        bet_recommendation = "Avoid betting (too close to call)"

    print(f"\n{team1} vs {team2} at {venue}")
    print(f"PREDICTED WINNER: {winner} ({win_prob:.1f}%)")
    print(f"BETTING ADVICE: {bet_recommendation}")

    return winner, win_prob, bet_recommendation

# Step 2: Use this code for any match prediction
# Before toss (just estimate)
predict_match_with_clear_winner(
    'Team1Name',  # e.g., 'Mumbai Indians'
    'Team2Name',  # e.g., 'Chennai Super Kings'
    'VenueName',  # e.g., 'Wankhede Stadium'
    'Team1Name',  # Assume Team1 wins toss
    'bat'        # Assume they choose to bat
)

# After toss (accurate)
predict_match_with_clear_winner(
    'Team1Name',
    'Team2Name',
    'VenueName',
    'ActualTossWinner',  # Team that won the toss
    'ActualDecision'     # 'bat' or 'field'
)

predict_match_with_clear_winner(
    'Kolkata Knight Riders',
    'Sunrisers Hyderabad',
    'M. A. Chidambaram Stadium',
    'Kolkata Knight Riders',
    'bat',
    'clear'
)

